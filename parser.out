Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> prog
Rule 1     prog -> prog1 prog2 MAIN LPAREN RPAREN LCURLY block RCURLY
Rule 2     prog1 -> dec_vars
Rule 3     prog1 -> empty
Rule 4     prog2 -> function prog2
Rule 5     prog2 -> empty
Rule 6     dec_vars -> VAR dec_vars1
Rule 7     dec_vars1 -> smp_type ID LBRACKET exp RBRACKET dec_vars3 SEMICOL dec_vars4
Rule 8     dec_vars1 -> smp_type ID dec_vars2 SEMICOL dec_vars4
Rule 9     dec_vars1 -> sp_type ID dec_vars2 SEMICOL dec_vars4
Rule 10    dec_vars2 -> COMMA ID dec_vars2
Rule 11    dec_vars2 -> empty
Rule 12    dec_vars3 -> LBRACKET exp RBRACKET
Rule 13    dec_vars3 -> empty
Rule 14    dec_vars4 -> dec_vars
Rule 15    dec_vars4 -> empty
Rule 16    smp_type -> INT
Rule 17    smp_type -> FLOAT
Rule 18    smp_type -> CHAR
Rule 19    sp_type -> FILE
Rule 20    function -> FUNC ID LPAREN param RPAREN ARROW smp_type LCURLY function1 block RETURN exp SEMICOL RCURLY
Rule 21    function -> FUNC ID LPAREN param RPAREN ARROW VOID LCURLY function1 block RCURLY
Rule 22    function1 -> dec_vars
Rule 23    function1 -> empty
Rule 24    param -> smp_type ID param1
Rule 25    param -> empty
Rule 26    param1 -> COMMA smp_type ID param1
Rule 27    param1 -> empty
Rule 28    block -> statement block
Rule 29    block -> empty
Rule 30    variable -> ID variable1
Rule 31    variable1 -> LBRACKET exp RBRACKET variable2
Rule 32    variable1 -> empty
Rule 33    variable2 -> LBRACKET exp RBRACKET
Rule 34    variable2 -> empty
Rule 35    statement -> assignment
Rule 36    statement -> c_input
Rule 37    statement -> c_print
Rule 38    statement -> condition
Rule 39    statement -> for_loop
Rule 40    statement -> while_loop
Rule 41    statement -> std_func
Rule 42    statement -> sp_func
Rule 43    assignment -> variable EQUAL assignment1 SEMICOL
Rule 44    assignment1 -> exp
Rule 45    assignment1 -> sp_func
Rule 46    c_input -> INPUT variable c_input1 SEMICOL
Rule 47    c_input1 -> COMMA variable c_input1
Rule 48    c_input1 -> empty
Rule 49    c_print -> PRINT LPAREN c_print1 RPAREN SEMICOL
Rule 50    c_print1 -> exp c_print2
Rule 51    c_print1 -> CTE_CHAR c_print2
Rule 52    c_print2 -> COMMA c_print1
Rule 53    c_print2 -> empty
Rule 54    condition -> IF LPAREN exp RPAREN LCURLY block RCURLY condition1
Rule 55    condition1 -> ELSE LCURLY block RCURLY
Rule 56    condition1 -> empty
Rule 57    for_loop -> FOR ID IN RANGE LPAREN exp COMMA exp RPAREN LCURLY block RCURLY
Rule 58    while_loop -> WHILE LPAREN exp RPAREN LCURLY block RCURLY
Rule 59    std_func -> ID LPAREN std_func1 RPAREN
Rule 60    std_func1 -> exp std_func2
Rule 61    std_func1 -> empty
Rule 62    std_func2 -> COMMA exp std_func2
Rule 63    std_func2 -> empty
Rule 64    sp_func -> generate_key_func
Rule 65    sp_func -> file_func
Rule 66    sp_func -> crypto_func
Rule 67    file_func -> open_file
Rule 68    file_func -> read_file
Rule 69    file_func -> write_file
Rule 70    file_func -> close_file
Rule 71    crypto_func -> encrypt_func
Rule 72    crypto_func -> decrypt_func
Rule 73    crypto_func -> hash_sha256
Rule 74    crypto_func -> hash_md5
Rule 75    generate_key_func -> GENERATE_KEY LPAREN RPAREN
Rule 76    open_file -> OPEN LPAREN CTE_CHAR RPAREN
Rule 77    read_file -> READ LPAREN ID RPAREN
Rule 78    write_file -> WRITE LPAREN CTE_CHAR ID RPAREN
Rule 79    close_file -> CLOSE LPAREN ID RPAREN
Rule 80    encrypt_func -> ENCRYPT LPAREN encrypt_func1 COMMA ID RPAREN
Rule 81    encrypt_func1 -> CTE_CHAR
Rule 82    encrypt_func1 -> ID
Rule 83    decrypt_func -> DECRYPT LPAREN decrypt_func1 COMMA ID RPAREN
Rule 84    decrypt_func1 -> CTE_CHAR
Rule 85    decrypt_func1 -> ID
Rule 86    hash_sha256 -> HASH_SHA256 LPAREN hash_sha2561 RPAREN
Rule 87    hash_sha2561 -> CTE_CHAR
Rule 88    hash_sha2561 -> ID
Rule 89    hash_md5 -> HASH_MD5 LPAREN hash_md51 RPAREN
Rule 90    hash_md51 -> CTE_CHAR
Rule 91    hash_md51 -> ID
Rule 92    exp -> t_exp exp1
Rule 93    exp1 -> OR exp
Rule 94    exp1 -> empty
Rule 95    t_exp -> g_exp t_exp1
Rule 96    t_exp1 -> AND t_exp
Rule 97    t_exp1 -> empty
Rule 98    g_exp -> m_exp g_exp1
Rule 99    g_exp1 -> GT m_exp
Rule 100   g_exp1 -> LT m_exp
Rule 101   g_exp1 -> GE m_exp
Rule 102   g_exp1 -> LE m_exp
Rule 103   g_exp1 -> EQ m_exp
Rule 104   g_exp1 -> NE m_exp
Rule 105   g_exp1 -> empty
Rule 106   m_exp -> term m_exp1
Rule 107   m_exp1 -> PLUS m_exp
Rule 108   m_exp1 -> MINUS m_exp
Rule 109   m_exp1 -> empty
Rule 110   term -> factor term1
Rule 111   term1 -> TIMES term
Rule 112   term1 -> DIVIDE term
Rule 113   term1 -> empty
Rule 114   factor -> LPAREN exp RPAREN
Rule 115   factor -> variable
Rule 116   factor -> std_func
Rule 117   factor -> CTE_INT
Rule 118   factor -> CTE_FLOAT
Rule 119   empty -> <empty>

Terminals, with rules where they appear

AND                  : 96
ARROW                : 20 21
CHAR                 : 18
CLOSE                : 79
COMMA                : 10 26 47 52 57 62 80 83
CTE_CHAR             : 51 76 78 81 84 87 90
CTE_FLOAT            : 118
CTE_INT              : 117
DECRYPT              : 83
DIVIDE               : 112
ELSE                 : 55
ENCRYPT              : 80
EQ                   : 103
EQUAL                : 43
FILE                 : 19
FLOAT                : 17
FOR                  : 57
FUNC                 : 20 21
GE                   : 101
GENERATE_KEY         : 75
GT                   : 99
HASH_MD5             : 89
HASH_SHA256          : 86
ID                   : 7 8 9 10 20 21 24 26 30 57 59 77 78 79 80 82 83 85 88 91
IF                   : 54
IN                   : 57
INPUT                : 46
INT                  : 16
LBRACKET             : 7 12 31 33
LCURLY               : 1 20 21 54 55 57 58
LE                   : 102
LPAREN               : 1 20 21 49 54 57 58 59 75 76 77 78 79 80 83 86 89 114
LT                   : 100
MAIN                 : 1
MINUS                : 108
NE                   : 104
OPEN                 : 76
OR                   : 93
PLUS                 : 107
PRINT                : 49
RANGE                : 57
RBRACKET             : 7 12 31 33
RCURLY               : 1 20 21 54 55 57 58
READ                 : 77
RETURN               : 20
RPAREN               : 1 20 21 49 54 57 58 59 75 76 77 78 79 80 83 86 89 114
SEMICOL              : 7 8 9 20 43 46 49
TIMES                : 111
VAR                  : 6
VOID                 : 21
WHILE                : 58
WRITE                : 78
error                : 

Nonterminals, with rules where they appear

assignment           : 35
assignment1          : 43
block                : 1 20 21 28 54 55 57 58
c_input              : 36
c_input1             : 46 47
c_print              : 37
c_print1             : 49 52
c_print2             : 50 51
close_file           : 70
condition            : 38
condition1           : 54
crypto_func          : 66
dec_vars             : 2 14 22
dec_vars1            : 6
dec_vars2            : 8 9 10
dec_vars3            : 7
dec_vars4            : 7 8 9
decrypt_func         : 72
decrypt_func1        : 83
empty                : 3 5 11 13 15 23 25 27 29 32 34 48 53 56 61 63 94 97 105 109 113
encrypt_func         : 71
encrypt_func1        : 80
exp                  : 7 12 20 31 33 44 50 54 57 57 58 60 62 93 114
exp1                 : 92
factor               : 110
file_func            : 65
for_loop             : 39
function             : 4
function1            : 20 21
g_exp                : 95
g_exp1               : 98
generate_key_func    : 64
hash_md5             : 74
hash_md51            : 89
hash_sha256          : 73
hash_sha2561         : 86
m_exp                : 98 99 100 101 102 103 104 107 108
m_exp1               : 106
open_file            : 67
param                : 20 21
param1               : 24 26
prog                 : 0
prog1                : 1
prog2                : 1 4
read_file            : 68
smp_type             : 7 8 20 24 26
sp_func              : 42 45
sp_type              : 9
statement            : 28
std_func             : 41 116
std_func1            : 59
std_func2            : 60 62
t_exp                : 92 96
t_exp1               : 95
term                 : 106 111 112
term1                : 110
variable             : 43 46 47 115
variable1            : 30
variable2            : 31
while_loop           : 40
write_file           : 69

Parsing method: LALR

state 0

    (0) S' -> . prog
    (1) prog -> . prog1 prog2 MAIN LPAREN RPAREN LCURLY block RCURLY
    (2) prog1 -> . dec_vars
    (3) prog1 -> . empty
    (6) dec_vars -> . VAR dec_vars1
    (119) empty -> .

    VAR             shift and go to state 5
    FUNC            reduce using rule 119 (empty -> .)
    MAIN            reduce using rule 119 (empty -> .)

    prog                           shift and go to state 1
    prog1                          shift and go to state 2
    dec_vars                       shift and go to state 3
    empty                          shift and go to state 4

state 1

    (0) S' -> prog .



state 2

    (1) prog -> prog1 . prog2 MAIN LPAREN RPAREN LCURLY block RCURLY
    (4) prog2 -> . function prog2
    (5) prog2 -> . empty
    (20) function -> . FUNC ID LPAREN param RPAREN ARROW smp_type LCURLY function1 block RETURN exp SEMICOL RCURLY
    (21) function -> . FUNC ID LPAREN param RPAREN ARROW VOID LCURLY function1 block RCURLY
    (119) empty -> .

    FUNC            shift and go to state 9
    MAIN            reduce using rule 119 (empty -> .)

    prog2                          shift and go to state 6
    function                       shift and go to state 7
    empty                          shift and go to state 8

state 3

    (2) prog1 -> dec_vars .

    FUNC            reduce using rule 2 (prog1 -> dec_vars .)
    MAIN            reduce using rule 2 (prog1 -> dec_vars .)


state 4

    (3) prog1 -> empty .

    FUNC            reduce using rule 3 (prog1 -> empty .)
    MAIN            reduce using rule 3 (prog1 -> empty .)


state 5

    (6) dec_vars -> VAR . dec_vars1
    (7) dec_vars1 -> . smp_type ID LBRACKET exp RBRACKET dec_vars3 SEMICOL dec_vars4
    (8) dec_vars1 -> . smp_type ID dec_vars2 SEMICOL dec_vars4
    (9) dec_vars1 -> . sp_type ID dec_vars2 SEMICOL dec_vars4
    (16) smp_type -> . INT
    (17) smp_type -> . FLOAT
    (18) smp_type -> . CHAR
    (19) sp_type -> . FILE

    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 15
    FILE            shift and go to state 16

    dec_vars1                      shift and go to state 10
    smp_type                       shift and go to state 11
    sp_type                        shift and go to state 12

state 6

    (1) prog -> prog1 prog2 . MAIN LPAREN RPAREN LCURLY block RCURLY

    MAIN            shift and go to state 17


state 7

    (4) prog2 -> function . prog2
    (4) prog2 -> . function prog2
    (5) prog2 -> . empty
    (20) function -> . FUNC ID LPAREN param RPAREN ARROW smp_type LCURLY function1 block RETURN exp SEMICOL RCURLY
    (21) function -> . FUNC ID LPAREN param RPAREN ARROW VOID LCURLY function1 block RCURLY
    (119) empty -> .

    FUNC            shift and go to state 9
    MAIN            reduce using rule 119 (empty -> .)

    function                       shift and go to state 7
    prog2                          shift and go to state 18
    empty                          shift and go to state 8

state 8

    (5) prog2 -> empty .

    MAIN            reduce using rule 5 (prog2 -> empty .)


state 9

    (20) function -> FUNC . ID LPAREN param RPAREN ARROW smp_type LCURLY function1 block RETURN exp SEMICOL RCURLY
    (21) function -> FUNC . ID LPAREN param RPAREN ARROW VOID LCURLY function1 block RCURLY

    ID              shift and go to state 19


state 10

    (6) dec_vars -> VAR dec_vars1 .

    FUNC            reduce using rule 6 (dec_vars -> VAR dec_vars1 .)
    MAIN            reduce using rule 6 (dec_vars -> VAR dec_vars1 .)
    INPUT           reduce using rule 6 (dec_vars -> VAR dec_vars1 .)
    PRINT           reduce using rule 6 (dec_vars -> VAR dec_vars1 .)
    IF              reduce using rule 6 (dec_vars -> VAR dec_vars1 .)
    FOR             reduce using rule 6 (dec_vars -> VAR dec_vars1 .)
    WHILE           reduce using rule 6 (dec_vars -> VAR dec_vars1 .)
    ID              reduce using rule 6 (dec_vars -> VAR dec_vars1 .)
    GENERATE_KEY    reduce using rule 6 (dec_vars -> VAR dec_vars1 .)
    OPEN            reduce using rule 6 (dec_vars -> VAR dec_vars1 .)
    READ            reduce using rule 6 (dec_vars -> VAR dec_vars1 .)
    WRITE           reduce using rule 6 (dec_vars -> VAR dec_vars1 .)
    CLOSE           reduce using rule 6 (dec_vars -> VAR dec_vars1 .)
    ENCRYPT         reduce using rule 6 (dec_vars -> VAR dec_vars1 .)
    DECRYPT         reduce using rule 6 (dec_vars -> VAR dec_vars1 .)
    HASH_SHA256     reduce using rule 6 (dec_vars -> VAR dec_vars1 .)
    HASH_MD5        reduce using rule 6 (dec_vars -> VAR dec_vars1 .)
    RETURN          reduce using rule 6 (dec_vars -> VAR dec_vars1 .)
    RCURLY          reduce using rule 6 (dec_vars -> VAR dec_vars1 .)


state 11

    (7) dec_vars1 -> smp_type . ID LBRACKET exp RBRACKET dec_vars3 SEMICOL dec_vars4
    (8) dec_vars1 -> smp_type . ID dec_vars2 SEMICOL dec_vars4

    ID              shift and go to state 20


state 12

    (9) dec_vars1 -> sp_type . ID dec_vars2 SEMICOL dec_vars4

    ID              shift and go to state 21


state 13

    (16) smp_type -> INT .

    ID              reduce using rule 16 (smp_type -> INT .)
    LCURLY          reduce using rule 16 (smp_type -> INT .)


state 14

    (17) smp_type -> FLOAT .

    ID              reduce using rule 17 (smp_type -> FLOAT .)
    LCURLY          reduce using rule 17 (smp_type -> FLOAT .)


state 15

    (18) smp_type -> CHAR .

    ID              reduce using rule 18 (smp_type -> CHAR .)
    LCURLY          reduce using rule 18 (smp_type -> CHAR .)


state 16

    (19) sp_type -> FILE .

    ID              reduce using rule 19 (sp_type -> FILE .)


state 17

    (1) prog -> prog1 prog2 MAIN . LPAREN RPAREN LCURLY block RCURLY

    LPAREN          shift and go to state 22


state 18

    (4) prog2 -> function prog2 .

    MAIN            reduce using rule 4 (prog2 -> function prog2 .)


state 19

    (20) function -> FUNC ID . LPAREN param RPAREN ARROW smp_type LCURLY function1 block RETURN exp SEMICOL RCURLY
    (21) function -> FUNC ID . LPAREN param RPAREN ARROW VOID LCURLY function1 block RCURLY

    LPAREN          shift and go to state 23


state 20

    (7) dec_vars1 -> smp_type ID . LBRACKET exp RBRACKET dec_vars3 SEMICOL dec_vars4
    (8) dec_vars1 -> smp_type ID . dec_vars2 SEMICOL dec_vars4
    (10) dec_vars2 -> . COMMA ID dec_vars2
    (11) dec_vars2 -> . empty
    (119) empty -> .

    LBRACKET        shift and go to state 24
    COMMA           shift and go to state 26
    SEMICOL         reduce using rule 119 (empty -> .)

    dec_vars2                      shift and go to state 25
    empty                          shift and go to state 27

state 21

    (9) dec_vars1 -> sp_type ID . dec_vars2 SEMICOL dec_vars4
    (10) dec_vars2 -> . COMMA ID dec_vars2
    (11) dec_vars2 -> . empty
    (119) empty -> .

    COMMA           shift and go to state 26
    SEMICOL         reduce using rule 119 (empty -> .)

    dec_vars2                      shift and go to state 28
    empty                          shift and go to state 27

state 22

    (1) prog -> prog1 prog2 MAIN LPAREN . RPAREN LCURLY block RCURLY

    RPAREN          shift and go to state 29


state 23

    (20) function -> FUNC ID LPAREN . param RPAREN ARROW smp_type LCURLY function1 block RETURN exp SEMICOL RCURLY
    (21) function -> FUNC ID LPAREN . param RPAREN ARROW VOID LCURLY function1 block RCURLY
    (24) param -> . smp_type ID param1
    (25) param -> . empty
    (16) smp_type -> . INT
    (17) smp_type -> . FLOAT
    (18) smp_type -> . CHAR
    (119) empty -> .

    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 15
    RPAREN          reduce using rule 119 (empty -> .)

    param                          shift and go to state 30
    smp_type                       shift and go to state 31
    empty                          shift and go to state 32

state 24

    (7) dec_vars1 -> smp_type ID LBRACKET . exp RBRACKET dec_vars3 SEMICOL dec_vars4
    (92) exp -> . t_exp exp1
    (95) t_exp -> . g_exp t_exp1
    (98) g_exp -> . m_exp g_exp1
    (106) m_exp -> . term m_exp1
    (110) term -> . factor term1
    (114) factor -> . LPAREN exp RPAREN
    (115) factor -> . variable
    (116) factor -> . std_func
    (117) factor -> . CTE_INT
    (118) factor -> . CTE_FLOAT
    (30) variable -> . ID variable1
    (59) std_func -> . ID LPAREN std_func1 RPAREN

    LPAREN          shift and go to state 40
    CTE_INT         shift and go to state 43
    CTE_FLOAT       shift and go to state 44
    ID              shift and go to state 33

    exp                            shift and go to state 34
    t_exp                          shift and go to state 35
    g_exp                          shift and go to state 36
    m_exp                          shift and go to state 37
    term                           shift and go to state 38
    factor                         shift and go to state 39
    variable                       shift and go to state 41
    std_func                       shift and go to state 42

state 25

    (8) dec_vars1 -> smp_type ID dec_vars2 . SEMICOL dec_vars4

    SEMICOL         shift and go to state 45


state 26

    (10) dec_vars2 -> COMMA . ID dec_vars2

    ID              shift and go to state 46


state 27

    (11) dec_vars2 -> empty .

    SEMICOL         reduce using rule 11 (dec_vars2 -> empty .)


state 28

    (9) dec_vars1 -> sp_type ID dec_vars2 . SEMICOL dec_vars4

    SEMICOL         shift and go to state 47


state 29

    (1) prog -> prog1 prog2 MAIN LPAREN RPAREN . LCURLY block RCURLY

    LCURLY          shift and go to state 48


state 30

    (20) function -> FUNC ID LPAREN param . RPAREN ARROW smp_type LCURLY function1 block RETURN exp SEMICOL RCURLY
    (21) function -> FUNC ID LPAREN param . RPAREN ARROW VOID LCURLY function1 block RCURLY

    RPAREN          shift and go to state 49


state 31

    (24) param -> smp_type . ID param1

    ID              shift and go to state 50


state 32

    (25) param -> empty .

    RPAREN          reduce using rule 25 (param -> empty .)


state 33

    (30) variable -> ID . variable1
    (59) std_func -> ID . LPAREN std_func1 RPAREN
    (31) variable1 -> . LBRACKET exp RBRACKET variable2
    (32) variable1 -> . empty
    (119) empty -> .

    LPAREN          shift and go to state 52
    LBRACKET        shift and go to state 53
    TIMES           reduce using rule 119 (empty -> .)
    DIVIDE          reduce using rule 119 (empty -> .)
    PLUS            reduce using rule 119 (empty -> .)
    MINUS           reduce using rule 119 (empty -> .)
    GT              reduce using rule 119 (empty -> .)
    LT              reduce using rule 119 (empty -> .)
    GE              reduce using rule 119 (empty -> .)
    LE              reduce using rule 119 (empty -> .)
    EQ              reduce using rule 119 (empty -> .)
    NE              reduce using rule 119 (empty -> .)
    AND             reduce using rule 119 (empty -> .)
    OR              reduce using rule 119 (empty -> .)
    RBRACKET        reduce using rule 119 (empty -> .)
    RPAREN          reduce using rule 119 (empty -> .)
    COMMA           reduce using rule 119 (empty -> .)
    SEMICOL         reduce using rule 119 (empty -> .)

    variable1                      shift and go to state 51
    empty                          shift and go to state 54

state 34

    (7) dec_vars1 -> smp_type ID LBRACKET exp . RBRACKET dec_vars3 SEMICOL dec_vars4

    RBRACKET        shift and go to state 55


state 35

    (92) exp -> t_exp . exp1
    (93) exp1 -> . OR exp
    (94) exp1 -> . empty
    (119) empty -> .

    OR              shift and go to state 57
    RBRACKET        reduce using rule 119 (empty -> .)
    RPAREN          reduce using rule 119 (empty -> .)
    COMMA           reduce using rule 119 (empty -> .)
    SEMICOL         reduce using rule 119 (empty -> .)

    exp1                           shift and go to state 56
    empty                          shift and go to state 58

state 36

    (95) t_exp -> g_exp . t_exp1
    (96) t_exp1 -> . AND t_exp
    (97) t_exp1 -> . empty
    (119) empty -> .

    AND             shift and go to state 60
    OR              reduce using rule 119 (empty -> .)
    RBRACKET        reduce using rule 119 (empty -> .)
    RPAREN          reduce using rule 119 (empty -> .)
    COMMA           reduce using rule 119 (empty -> .)
    SEMICOL         reduce using rule 119 (empty -> .)

    t_exp1                         shift and go to state 59
    empty                          shift and go to state 61

state 37

    (98) g_exp -> m_exp . g_exp1
    (99) g_exp1 -> . GT m_exp
    (100) g_exp1 -> . LT m_exp
    (101) g_exp1 -> . GE m_exp
    (102) g_exp1 -> . LE m_exp
    (103) g_exp1 -> . EQ m_exp
    (104) g_exp1 -> . NE m_exp
    (105) g_exp1 -> . empty
    (119) empty -> .

    GT              shift and go to state 63
    LT              shift and go to state 64
    GE              shift and go to state 65
    LE              shift and go to state 66
    EQ              shift and go to state 67
    NE              shift and go to state 68
    AND             reduce using rule 119 (empty -> .)
    OR              reduce using rule 119 (empty -> .)
    RBRACKET        reduce using rule 119 (empty -> .)
    RPAREN          reduce using rule 119 (empty -> .)
    COMMA           reduce using rule 119 (empty -> .)
    SEMICOL         reduce using rule 119 (empty -> .)

    g_exp1                         shift and go to state 62
    empty                          shift and go to state 69

state 38

    (106) m_exp -> term . m_exp1
    (107) m_exp1 -> . PLUS m_exp
    (108) m_exp1 -> . MINUS m_exp
    (109) m_exp1 -> . empty
    (119) empty -> .

    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    GT              reduce using rule 119 (empty -> .)
    LT              reduce using rule 119 (empty -> .)
    GE              reduce using rule 119 (empty -> .)
    LE              reduce using rule 119 (empty -> .)
    EQ              reduce using rule 119 (empty -> .)
    NE              reduce using rule 119 (empty -> .)
    AND             reduce using rule 119 (empty -> .)
    OR              reduce using rule 119 (empty -> .)
    RBRACKET        reduce using rule 119 (empty -> .)
    RPAREN          reduce using rule 119 (empty -> .)
    COMMA           reduce using rule 119 (empty -> .)
    SEMICOL         reduce using rule 119 (empty -> .)

    m_exp1                         shift and go to state 70
    empty                          shift and go to state 73

state 39

    (110) term -> factor . term1
    (111) term1 -> . TIMES term
    (112) term1 -> . DIVIDE term
    (113) term1 -> . empty
    (119) empty -> .

    TIMES           shift and go to state 75
    DIVIDE          shift and go to state 76
    PLUS            reduce using rule 119 (empty -> .)
    MINUS           reduce using rule 119 (empty -> .)
    GT              reduce using rule 119 (empty -> .)
    LT              reduce using rule 119 (empty -> .)
    GE              reduce using rule 119 (empty -> .)
    LE              reduce using rule 119 (empty -> .)
    EQ              reduce using rule 119 (empty -> .)
    NE              reduce using rule 119 (empty -> .)
    AND             reduce using rule 119 (empty -> .)
    OR              reduce using rule 119 (empty -> .)
    RBRACKET        reduce using rule 119 (empty -> .)
    RPAREN          reduce using rule 119 (empty -> .)
    COMMA           reduce using rule 119 (empty -> .)
    SEMICOL         reduce using rule 119 (empty -> .)

    term1                          shift and go to state 74
    empty                          shift and go to state 77

state 40

    (114) factor -> LPAREN . exp RPAREN
    (92) exp -> . t_exp exp1
    (95) t_exp -> . g_exp t_exp1
    (98) g_exp -> . m_exp g_exp1
    (106) m_exp -> . term m_exp1
    (110) term -> . factor term1
    (114) factor -> . LPAREN exp RPAREN
    (115) factor -> . variable
    (116) factor -> . std_func
    (117) factor -> . CTE_INT
    (118) factor -> . CTE_FLOAT
    (30) variable -> . ID variable1
    (59) std_func -> . ID LPAREN std_func1 RPAREN

    LPAREN          shift and go to state 40
    CTE_INT         shift and go to state 43
    CTE_FLOAT       shift and go to state 44
    ID              shift and go to state 33

    exp                            shift and go to state 78
    t_exp                          shift and go to state 35
    g_exp                          shift and go to state 36
    m_exp                          shift and go to state 37
    term                           shift and go to state 38
    factor                         shift and go to state 39
    variable                       shift and go to state 41
    std_func                       shift and go to state 42

state 41

    (115) factor -> variable .

    TIMES           reduce using rule 115 (factor -> variable .)
    DIVIDE          reduce using rule 115 (factor -> variable .)
    PLUS            reduce using rule 115 (factor -> variable .)
    MINUS           reduce using rule 115 (factor -> variable .)
    GT              reduce using rule 115 (factor -> variable .)
    LT              reduce using rule 115 (factor -> variable .)
    GE              reduce using rule 115 (factor -> variable .)
    LE              reduce using rule 115 (factor -> variable .)
    EQ              reduce using rule 115 (factor -> variable .)
    NE              reduce using rule 115 (factor -> variable .)
    AND             reduce using rule 115 (factor -> variable .)
    OR              reduce using rule 115 (factor -> variable .)
    RBRACKET        reduce using rule 115 (factor -> variable .)
    RPAREN          reduce using rule 115 (factor -> variable .)
    COMMA           reduce using rule 115 (factor -> variable .)
    SEMICOL         reduce using rule 115 (factor -> variable .)


state 42

    (116) factor -> std_func .

    TIMES           reduce using rule 116 (factor -> std_func .)
    DIVIDE          reduce using rule 116 (factor -> std_func .)
    PLUS            reduce using rule 116 (factor -> std_func .)
    MINUS           reduce using rule 116 (factor -> std_func .)
    GT              reduce using rule 116 (factor -> std_func .)
    LT              reduce using rule 116 (factor -> std_func .)
    GE              reduce using rule 116 (factor -> std_func .)
    LE              reduce using rule 116 (factor -> std_func .)
    EQ              reduce using rule 116 (factor -> std_func .)
    NE              reduce using rule 116 (factor -> std_func .)
    AND             reduce using rule 116 (factor -> std_func .)
    OR              reduce using rule 116 (factor -> std_func .)
    RBRACKET        reduce using rule 116 (factor -> std_func .)
    RPAREN          reduce using rule 116 (factor -> std_func .)
    COMMA           reduce using rule 116 (factor -> std_func .)
    SEMICOL         reduce using rule 116 (factor -> std_func .)


state 43

    (117) factor -> CTE_INT .

    TIMES           reduce using rule 117 (factor -> CTE_INT .)
    DIVIDE          reduce using rule 117 (factor -> CTE_INT .)
    PLUS            reduce using rule 117 (factor -> CTE_INT .)
    MINUS           reduce using rule 117 (factor -> CTE_INT .)
    GT              reduce using rule 117 (factor -> CTE_INT .)
    LT              reduce using rule 117 (factor -> CTE_INT .)
    GE              reduce using rule 117 (factor -> CTE_INT .)
    LE              reduce using rule 117 (factor -> CTE_INT .)
    EQ              reduce using rule 117 (factor -> CTE_INT .)
    NE              reduce using rule 117 (factor -> CTE_INT .)
    AND             reduce using rule 117 (factor -> CTE_INT .)
    OR              reduce using rule 117 (factor -> CTE_INT .)
    RBRACKET        reduce using rule 117 (factor -> CTE_INT .)
    RPAREN          reduce using rule 117 (factor -> CTE_INT .)
    COMMA           reduce using rule 117 (factor -> CTE_INT .)
    SEMICOL         reduce using rule 117 (factor -> CTE_INT .)


state 44

    (118) factor -> CTE_FLOAT .

    TIMES           reduce using rule 118 (factor -> CTE_FLOAT .)
    DIVIDE          reduce using rule 118 (factor -> CTE_FLOAT .)
    PLUS            reduce using rule 118 (factor -> CTE_FLOAT .)
    MINUS           reduce using rule 118 (factor -> CTE_FLOAT .)
    GT              reduce using rule 118 (factor -> CTE_FLOAT .)
    LT              reduce using rule 118 (factor -> CTE_FLOAT .)
    GE              reduce using rule 118 (factor -> CTE_FLOAT .)
    LE              reduce using rule 118 (factor -> CTE_FLOAT .)
    EQ              reduce using rule 118 (factor -> CTE_FLOAT .)
    NE              reduce using rule 118 (factor -> CTE_FLOAT .)
    AND             reduce using rule 118 (factor -> CTE_FLOAT .)
    OR              reduce using rule 118 (factor -> CTE_FLOAT .)
    RBRACKET        reduce using rule 118 (factor -> CTE_FLOAT .)
    RPAREN          reduce using rule 118 (factor -> CTE_FLOAT .)
    COMMA           reduce using rule 118 (factor -> CTE_FLOAT .)
    SEMICOL         reduce using rule 118 (factor -> CTE_FLOAT .)


state 45

    (8) dec_vars1 -> smp_type ID dec_vars2 SEMICOL . dec_vars4
    (14) dec_vars4 -> . dec_vars
    (15) dec_vars4 -> . empty
    (6) dec_vars -> . VAR dec_vars1
    (119) empty -> .

    VAR             shift and go to state 5
    FUNC            reduce using rule 119 (empty -> .)
    MAIN            reduce using rule 119 (empty -> .)
    INPUT           reduce using rule 119 (empty -> .)
    PRINT           reduce using rule 119 (empty -> .)
    IF              reduce using rule 119 (empty -> .)
    FOR             reduce using rule 119 (empty -> .)
    WHILE           reduce using rule 119 (empty -> .)
    ID              reduce using rule 119 (empty -> .)
    GENERATE_KEY    reduce using rule 119 (empty -> .)
    OPEN            reduce using rule 119 (empty -> .)
    READ            reduce using rule 119 (empty -> .)
    WRITE           reduce using rule 119 (empty -> .)
    CLOSE           reduce using rule 119 (empty -> .)
    ENCRYPT         reduce using rule 119 (empty -> .)
    DECRYPT         reduce using rule 119 (empty -> .)
    HASH_SHA256     reduce using rule 119 (empty -> .)
    HASH_MD5        reduce using rule 119 (empty -> .)
    RETURN          reduce using rule 119 (empty -> .)
    RCURLY          reduce using rule 119 (empty -> .)

    dec_vars4                      shift and go to state 79
    dec_vars                       shift and go to state 80
    empty                          shift and go to state 81

state 46

    (10) dec_vars2 -> COMMA ID . dec_vars2
    (10) dec_vars2 -> . COMMA ID dec_vars2
    (11) dec_vars2 -> . empty
    (119) empty -> .

    COMMA           shift and go to state 26
    SEMICOL         reduce using rule 119 (empty -> .)

    dec_vars2                      shift and go to state 82
    empty                          shift and go to state 27

state 47

    (9) dec_vars1 -> sp_type ID dec_vars2 SEMICOL . dec_vars4
    (14) dec_vars4 -> . dec_vars
    (15) dec_vars4 -> . empty
    (6) dec_vars -> . VAR dec_vars1
    (119) empty -> .

    VAR             shift and go to state 5
    FUNC            reduce using rule 119 (empty -> .)
    MAIN            reduce using rule 119 (empty -> .)
    INPUT           reduce using rule 119 (empty -> .)
    PRINT           reduce using rule 119 (empty -> .)
    IF              reduce using rule 119 (empty -> .)
    FOR             reduce using rule 119 (empty -> .)
    WHILE           reduce using rule 119 (empty -> .)
    ID              reduce using rule 119 (empty -> .)
    GENERATE_KEY    reduce using rule 119 (empty -> .)
    OPEN            reduce using rule 119 (empty -> .)
    READ            reduce using rule 119 (empty -> .)
    WRITE           reduce using rule 119 (empty -> .)
    CLOSE           reduce using rule 119 (empty -> .)
    ENCRYPT         reduce using rule 119 (empty -> .)
    DECRYPT         reduce using rule 119 (empty -> .)
    HASH_SHA256     reduce using rule 119 (empty -> .)
    HASH_MD5        reduce using rule 119 (empty -> .)
    RETURN          reduce using rule 119 (empty -> .)
    RCURLY          reduce using rule 119 (empty -> .)

    dec_vars4                      shift and go to state 83
    dec_vars                       shift and go to state 80
    empty                          shift and go to state 81

state 48

    (1) prog -> prog1 prog2 MAIN LPAREN RPAREN LCURLY . block RCURLY
    (28) block -> . statement block
    (29) block -> . empty
    (35) statement -> . assignment
    (36) statement -> . c_input
    (37) statement -> . c_print
    (38) statement -> . condition
    (39) statement -> . for_loop
    (40) statement -> . while_loop
    (41) statement -> . std_func
    (42) statement -> . sp_func
    (119) empty -> .
    (43) assignment -> . variable EQUAL assignment1 SEMICOL
    (46) c_input -> . INPUT variable c_input1 SEMICOL
    (49) c_print -> . PRINT LPAREN c_print1 RPAREN SEMICOL
    (54) condition -> . IF LPAREN exp RPAREN LCURLY block RCURLY condition1
    (57) for_loop -> . FOR ID IN RANGE LPAREN exp COMMA exp RPAREN LCURLY block RCURLY
    (58) while_loop -> . WHILE LPAREN exp RPAREN LCURLY block RCURLY
    (59) std_func -> . ID LPAREN std_func1 RPAREN
    (64) sp_func -> . generate_key_func
    (65) sp_func -> . file_func
    (66) sp_func -> . crypto_func
    (30) variable -> . ID variable1
    (75) generate_key_func -> . GENERATE_KEY LPAREN RPAREN
    (67) file_func -> . open_file
    (68) file_func -> . read_file
    (69) file_func -> . write_file
    (70) file_func -> . close_file
    (71) crypto_func -> . encrypt_func
    (72) crypto_func -> . decrypt_func
    (73) crypto_func -> . hash_sha256
    (74) crypto_func -> . hash_md5
    (76) open_file -> . OPEN LPAREN CTE_CHAR RPAREN
    (77) read_file -> . READ LPAREN ID RPAREN
    (78) write_file -> . WRITE LPAREN CTE_CHAR ID RPAREN
    (79) close_file -> . CLOSE LPAREN ID RPAREN
    (80) encrypt_func -> . ENCRYPT LPAREN encrypt_func1 COMMA ID RPAREN
    (83) decrypt_func -> . DECRYPT LPAREN decrypt_func1 COMMA ID RPAREN
    (86) hash_sha256 -> . HASH_SHA256 LPAREN hash_sha2561 RPAREN
    (89) hash_md5 -> . HASH_MD5 LPAREN hash_md51 RPAREN

    RCURLY          reduce using rule 119 (empty -> .)
    INPUT           shift and go to state 96
    PRINT           shift and go to state 97
    IF              shift and go to state 98
    FOR             shift and go to state 99
    WHILE           shift and go to state 101
    ID              shift and go to state 100
    GENERATE_KEY    shift and go to state 105
    OPEN            shift and go to state 114
    READ            shift and go to state 115
    WRITE           shift and go to state 116
    CLOSE           shift and go to state 117
    ENCRYPT         shift and go to state 118
    DECRYPT         shift and go to state 119
    HASH_SHA256     shift and go to state 120
    HASH_MD5        shift and go to state 121

    block                          shift and go to state 84
    statement                      shift and go to state 85
    empty                          shift and go to state 86
    assignment                     shift and go to state 87
    c_input                        shift and go to state 88
    c_print                        shift and go to state 89
    condition                      shift and go to state 90
    for_loop                       shift and go to state 91
    while_loop                     shift and go to state 92
    std_func                       shift and go to state 93
    sp_func                        shift and go to state 94
    variable                       shift and go to state 95
    generate_key_func              shift and go to state 102
    file_func                      shift and go to state 103
    crypto_func                    shift and go to state 104
    open_file                      shift and go to state 106
    read_file                      shift and go to state 107
    write_file                     shift and go to state 108
    close_file                     shift and go to state 109
    encrypt_func                   shift and go to state 110
    decrypt_func                   shift and go to state 111
    hash_sha256                    shift and go to state 112
    hash_md5                       shift and go to state 113

state 49

    (20) function -> FUNC ID LPAREN param RPAREN . ARROW smp_type LCURLY function1 block RETURN exp SEMICOL RCURLY
    (21) function -> FUNC ID LPAREN param RPAREN . ARROW VOID LCURLY function1 block RCURLY

    ARROW           shift and go to state 122


state 50

    (24) param -> smp_type ID . param1
    (26) param1 -> . COMMA smp_type ID param1
    (27) param1 -> . empty
    (119) empty -> .

    COMMA           shift and go to state 124
    RPAREN          reduce using rule 119 (empty -> .)

    param1                         shift and go to state 123
    empty                          shift and go to state 125

state 51

    (30) variable -> ID variable1 .

    TIMES           reduce using rule 30 (variable -> ID variable1 .)
    DIVIDE          reduce using rule 30 (variable -> ID variable1 .)
    PLUS            reduce using rule 30 (variable -> ID variable1 .)
    MINUS           reduce using rule 30 (variable -> ID variable1 .)
    GT              reduce using rule 30 (variable -> ID variable1 .)
    LT              reduce using rule 30 (variable -> ID variable1 .)
    GE              reduce using rule 30 (variable -> ID variable1 .)
    LE              reduce using rule 30 (variable -> ID variable1 .)
    EQ              reduce using rule 30 (variable -> ID variable1 .)
    NE              reduce using rule 30 (variable -> ID variable1 .)
    AND             reduce using rule 30 (variable -> ID variable1 .)
    OR              reduce using rule 30 (variable -> ID variable1 .)
    RBRACKET        reduce using rule 30 (variable -> ID variable1 .)
    RPAREN          reduce using rule 30 (variable -> ID variable1 .)
    EQUAL           reduce using rule 30 (variable -> ID variable1 .)
    COMMA           reduce using rule 30 (variable -> ID variable1 .)
    SEMICOL         reduce using rule 30 (variable -> ID variable1 .)


state 52

    (59) std_func -> ID LPAREN . std_func1 RPAREN
    (60) std_func1 -> . exp std_func2
    (61) std_func1 -> . empty
    (92) exp -> . t_exp exp1
    (119) empty -> .
    (95) t_exp -> . g_exp t_exp1
    (98) g_exp -> . m_exp g_exp1
    (106) m_exp -> . term m_exp1
    (110) term -> . factor term1
    (114) factor -> . LPAREN exp RPAREN
    (115) factor -> . variable
    (116) factor -> . std_func
    (117) factor -> . CTE_INT
    (118) factor -> . CTE_FLOAT
    (30) variable -> . ID variable1
    (59) std_func -> . ID LPAREN std_func1 RPAREN

    RPAREN          reduce using rule 119 (empty -> .)
    LPAREN          shift and go to state 40
    CTE_INT         shift and go to state 43
    CTE_FLOAT       shift and go to state 44
    ID              shift and go to state 33

    std_func1                      shift and go to state 126
    exp                            shift and go to state 127
    empty                          shift and go to state 128
    t_exp                          shift and go to state 35
    g_exp                          shift and go to state 36
    m_exp                          shift and go to state 37
    term                           shift and go to state 38
    factor                         shift and go to state 39
    variable                       shift and go to state 41
    std_func                       shift and go to state 42

state 53

    (31) variable1 -> LBRACKET . exp RBRACKET variable2
    (92) exp -> . t_exp exp1
    (95) t_exp -> . g_exp t_exp1
    (98) g_exp -> . m_exp g_exp1
    (106) m_exp -> . term m_exp1
    (110) term -> . factor term1
    (114) factor -> . LPAREN exp RPAREN
    (115) factor -> . variable
    (116) factor -> . std_func
    (117) factor -> . CTE_INT
    (118) factor -> . CTE_FLOAT
    (30) variable -> . ID variable1
    (59) std_func -> . ID LPAREN std_func1 RPAREN

    LPAREN          shift and go to state 40
    CTE_INT         shift and go to state 43
    CTE_FLOAT       shift and go to state 44
    ID              shift and go to state 33

    exp                            shift and go to state 129
    t_exp                          shift and go to state 35
    g_exp                          shift and go to state 36
    m_exp                          shift and go to state 37
    term                           shift and go to state 38
    factor                         shift and go to state 39
    variable                       shift and go to state 41
    std_func                       shift and go to state 42

state 54

    (32) variable1 -> empty .

    TIMES           reduce using rule 32 (variable1 -> empty .)
    DIVIDE          reduce using rule 32 (variable1 -> empty .)
    PLUS            reduce using rule 32 (variable1 -> empty .)
    MINUS           reduce using rule 32 (variable1 -> empty .)
    GT              reduce using rule 32 (variable1 -> empty .)
    LT              reduce using rule 32 (variable1 -> empty .)
    GE              reduce using rule 32 (variable1 -> empty .)
    LE              reduce using rule 32 (variable1 -> empty .)
    EQ              reduce using rule 32 (variable1 -> empty .)
    NE              reduce using rule 32 (variable1 -> empty .)
    AND             reduce using rule 32 (variable1 -> empty .)
    OR              reduce using rule 32 (variable1 -> empty .)
    RBRACKET        reduce using rule 32 (variable1 -> empty .)
    RPAREN          reduce using rule 32 (variable1 -> empty .)
    COMMA           reduce using rule 32 (variable1 -> empty .)
    SEMICOL         reduce using rule 32 (variable1 -> empty .)
    EQUAL           reduce using rule 32 (variable1 -> empty .)


state 55

    (7) dec_vars1 -> smp_type ID LBRACKET exp RBRACKET . dec_vars3 SEMICOL dec_vars4
    (12) dec_vars3 -> . LBRACKET exp RBRACKET
    (13) dec_vars3 -> . empty
    (119) empty -> .

    LBRACKET        shift and go to state 130
    SEMICOL         reduce using rule 119 (empty -> .)

    dec_vars3                      shift and go to state 131
    empty                          shift and go to state 132

state 56

    (92) exp -> t_exp exp1 .

    RBRACKET        reduce using rule 92 (exp -> t_exp exp1 .)
    RPAREN          reduce using rule 92 (exp -> t_exp exp1 .)
    COMMA           reduce using rule 92 (exp -> t_exp exp1 .)
    SEMICOL         reduce using rule 92 (exp -> t_exp exp1 .)


state 57

    (93) exp1 -> OR . exp
    (92) exp -> . t_exp exp1
    (95) t_exp -> . g_exp t_exp1
    (98) g_exp -> . m_exp g_exp1
    (106) m_exp -> . term m_exp1
    (110) term -> . factor term1
    (114) factor -> . LPAREN exp RPAREN
    (115) factor -> . variable
    (116) factor -> . std_func
    (117) factor -> . CTE_INT
    (118) factor -> . CTE_FLOAT
    (30) variable -> . ID variable1
    (59) std_func -> . ID LPAREN std_func1 RPAREN

    LPAREN          shift and go to state 40
    CTE_INT         shift and go to state 43
    CTE_FLOAT       shift and go to state 44
    ID              shift and go to state 33

    exp                            shift and go to state 133
    t_exp                          shift and go to state 35
    g_exp                          shift and go to state 36
    m_exp                          shift and go to state 37
    term                           shift and go to state 38
    factor                         shift and go to state 39
    variable                       shift and go to state 41
    std_func                       shift and go to state 42

state 58

    (94) exp1 -> empty .

    RBRACKET        reduce using rule 94 (exp1 -> empty .)
    RPAREN          reduce using rule 94 (exp1 -> empty .)
    COMMA           reduce using rule 94 (exp1 -> empty .)
    SEMICOL         reduce using rule 94 (exp1 -> empty .)


state 59

    (95) t_exp -> g_exp t_exp1 .

    OR              reduce using rule 95 (t_exp -> g_exp t_exp1 .)
    RBRACKET        reduce using rule 95 (t_exp -> g_exp t_exp1 .)
    RPAREN          reduce using rule 95 (t_exp -> g_exp t_exp1 .)
    COMMA           reduce using rule 95 (t_exp -> g_exp t_exp1 .)
    SEMICOL         reduce using rule 95 (t_exp -> g_exp t_exp1 .)


state 60

    (96) t_exp1 -> AND . t_exp
    (95) t_exp -> . g_exp t_exp1
    (98) g_exp -> . m_exp g_exp1
    (106) m_exp -> . term m_exp1
    (110) term -> . factor term1
    (114) factor -> . LPAREN exp RPAREN
    (115) factor -> . variable
    (116) factor -> . std_func
    (117) factor -> . CTE_INT
    (118) factor -> . CTE_FLOAT
    (30) variable -> . ID variable1
    (59) std_func -> . ID LPAREN std_func1 RPAREN

    LPAREN          shift and go to state 40
    CTE_INT         shift and go to state 43
    CTE_FLOAT       shift and go to state 44
    ID              shift and go to state 33

    t_exp                          shift and go to state 134
    g_exp                          shift and go to state 36
    m_exp                          shift and go to state 37
    term                           shift and go to state 38
    factor                         shift and go to state 39
    variable                       shift and go to state 41
    std_func                       shift and go to state 42

state 61

    (97) t_exp1 -> empty .

    OR              reduce using rule 97 (t_exp1 -> empty .)
    RBRACKET        reduce using rule 97 (t_exp1 -> empty .)
    RPAREN          reduce using rule 97 (t_exp1 -> empty .)
    COMMA           reduce using rule 97 (t_exp1 -> empty .)
    SEMICOL         reduce using rule 97 (t_exp1 -> empty .)


state 62

    (98) g_exp -> m_exp g_exp1 .

    AND             reduce using rule 98 (g_exp -> m_exp g_exp1 .)
    OR              reduce using rule 98 (g_exp -> m_exp g_exp1 .)
    RBRACKET        reduce using rule 98 (g_exp -> m_exp g_exp1 .)
    RPAREN          reduce using rule 98 (g_exp -> m_exp g_exp1 .)
    COMMA           reduce using rule 98 (g_exp -> m_exp g_exp1 .)
    SEMICOL         reduce using rule 98 (g_exp -> m_exp g_exp1 .)


state 63

    (99) g_exp1 -> GT . m_exp
    (106) m_exp -> . term m_exp1
    (110) term -> . factor term1
    (114) factor -> . LPAREN exp RPAREN
    (115) factor -> . variable
    (116) factor -> . std_func
    (117) factor -> . CTE_INT
    (118) factor -> . CTE_FLOAT
    (30) variable -> . ID variable1
    (59) std_func -> . ID LPAREN std_func1 RPAREN

    LPAREN          shift and go to state 40
    CTE_INT         shift and go to state 43
    CTE_FLOAT       shift and go to state 44
    ID              shift and go to state 33

    m_exp                          shift and go to state 135
    term                           shift and go to state 38
    factor                         shift and go to state 39
    variable                       shift and go to state 41
    std_func                       shift and go to state 42

state 64

    (100) g_exp1 -> LT . m_exp
    (106) m_exp -> . term m_exp1
    (110) term -> . factor term1
    (114) factor -> . LPAREN exp RPAREN
    (115) factor -> . variable
    (116) factor -> . std_func
    (117) factor -> . CTE_INT
    (118) factor -> . CTE_FLOAT
    (30) variable -> . ID variable1
    (59) std_func -> . ID LPAREN std_func1 RPAREN

    LPAREN          shift and go to state 40
    CTE_INT         shift and go to state 43
    CTE_FLOAT       shift and go to state 44
    ID              shift and go to state 33

    m_exp                          shift and go to state 136
    term                           shift and go to state 38
    factor                         shift and go to state 39
    variable                       shift and go to state 41
    std_func                       shift and go to state 42

state 65

    (101) g_exp1 -> GE . m_exp
    (106) m_exp -> . term m_exp1
    (110) term -> . factor term1
    (114) factor -> . LPAREN exp RPAREN
    (115) factor -> . variable
    (116) factor -> . std_func
    (117) factor -> . CTE_INT
    (118) factor -> . CTE_FLOAT
    (30) variable -> . ID variable1
    (59) std_func -> . ID LPAREN std_func1 RPAREN

    LPAREN          shift and go to state 40
    CTE_INT         shift and go to state 43
    CTE_FLOAT       shift and go to state 44
    ID              shift and go to state 33

    m_exp                          shift and go to state 137
    term                           shift and go to state 38
    factor                         shift and go to state 39
    variable                       shift and go to state 41
    std_func                       shift and go to state 42

state 66

    (102) g_exp1 -> LE . m_exp
    (106) m_exp -> . term m_exp1
    (110) term -> . factor term1
    (114) factor -> . LPAREN exp RPAREN
    (115) factor -> . variable
    (116) factor -> . std_func
    (117) factor -> . CTE_INT
    (118) factor -> . CTE_FLOAT
    (30) variable -> . ID variable1
    (59) std_func -> . ID LPAREN std_func1 RPAREN

    LPAREN          shift and go to state 40
    CTE_INT         shift and go to state 43
    CTE_FLOAT       shift and go to state 44
    ID              shift and go to state 33

    m_exp                          shift and go to state 138
    term                           shift and go to state 38
    factor                         shift and go to state 39
    variable                       shift and go to state 41
    std_func                       shift and go to state 42

state 67

    (103) g_exp1 -> EQ . m_exp
    (106) m_exp -> . term m_exp1
    (110) term -> . factor term1
    (114) factor -> . LPAREN exp RPAREN
    (115) factor -> . variable
    (116) factor -> . std_func
    (117) factor -> . CTE_INT
    (118) factor -> . CTE_FLOAT
    (30) variable -> . ID variable1
    (59) std_func -> . ID LPAREN std_func1 RPAREN

    LPAREN          shift and go to state 40
    CTE_INT         shift and go to state 43
    CTE_FLOAT       shift and go to state 44
    ID              shift and go to state 33

    m_exp                          shift and go to state 139
    term                           shift and go to state 38
    factor                         shift and go to state 39
    variable                       shift and go to state 41
    std_func                       shift and go to state 42

state 68

    (104) g_exp1 -> NE . m_exp
    (106) m_exp -> . term m_exp1
    (110) term -> . factor term1
    (114) factor -> . LPAREN exp RPAREN
    (115) factor -> . variable
    (116) factor -> . std_func
    (117) factor -> . CTE_INT
    (118) factor -> . CTE_FLOAT
    (30) variable -> . ID variable1
    (59) std_func -> . ID LPAREN std_func1 RPAREN

    LPAREN          shift and go to state 40
    CTE_INT         shift and go to state 43
    CTE_FLOAT       shift and go to state 44
    ID              shift and go to state 33

    m_exp                          shift and go to state 140
    term                           shift and go to state 38
    factor                         shift and go to state 39
    variable                       shift and go to state 41
    std_func                       shift and go to state 42

state 69

    (105) g_exp1 -> empty .

    AND             reduce using rule 105 (g_exp1 -> empty .)
    OR              reduce using rule 105 (g_exp1 -> empty .)
    RBRACKET        reduce using rule 105 (g_exp1 -> empty .)
    RPAREN          reduce using rule 105 (g_exp1 -> empty .)
    COMMA           reduce using rule 105 (g_exp1 -> empty .)
    SEMICOL         reduce using rule 105 (g_exp1 -> empty .)


state 70

    (106) m_exp -> term m_exp1 .

    GT              reduce using rule 106 (m_exp -> term m_exp1 .)
    LT              reduce using rule 106 (m_exp -> term m_exp1 .)
    GE              reduce using rule 106 (m_exp -> term m_exp1 .)
    LE              reduce using rule 106 (m_exp -> term m_exp1 .)
    EQ              reduce using rule 106 (m_exp -> term m_exp1 .)
    NE              reduce using rule 106 (m_exp -> term m_exp1 .)
    AND             reduce using rule 106 (m_exp -> term m_exp1 .)
    OR              reduce using rule 106 (m_exp -> term m_exp1 .)
    RBRACKET        reduce using rule 106 (m_exp -> term m_exp1 .)
    RPAREN          reduce using rule 106 (m_exp -> term m_exp1 .)
    COMMA           reduce using rule 106 (m_exp -> term m_exp1 .)
    SEMICOL         reduce using rule 106 (m_exp -> term m_exp1 .)


state 71

    (107) m_exp1 -> PLUS . m_exp
    (106) m_exp -> . term m_exp1
    (110) term -> . factor term1
    (114) factor -> . LPAREN exp RPAREN
    (115) factor -> . variable
    (116) factor -> . std_func
    (117) factor -> . CTE_INT
    (118) factor -> . CTE_FLOAT
    (30) variable -> . ID variable1
    (59) std_func -> . ID LPAREN std_func1 RPAREN

    LPAREN          shift and go to state 40
    CTE_INT         shift and go to state 43
    CTE_FLOAT       shift and go to state 44
    ID              shift and go to state 33

    m_exp                          shift and go to state 141
    term                           shift and go to state 38
    factor                         shift and go to state 39
    variable                       shift and go to state 41
    std_func                       shift and go to state 42

state 72

    (108) m_exp1 -> MINUS . m_exp
    (106) m_exp -> . term m_exp1
    (110) term -> . factor term1
    (114) factor -> . LPAREN exp RPAREN
    (115) factor -> . variable
    (116) factor -> . std_func
    (117) factor -> . CTE_INT
    (118) factor -> . CTE_FLOAT
    (30) variable -> . ID variable1
    (59) std_func -> . ID LPAREN std_func1 RPAREN

    LPAREN          shift and go to state 40
    CTE_INT         shift and go to state 43
    CTE_FLOAT       shift and go to state 44
    ID              shift and go to state 33

    m_exp                          shift and go to state 142
    term                           shift and go to state 38
    factor                         shift and go to state 39
    variable                       shift and go to state 41
    std_func                       shift and go to state 42

state 73

    (109) m_exp1 -> empty .

    GT              reduce using rule 109 (m_exp1 -> empty .)
    LT              reduce using rule 109 (m_exp1 -> empty .)
    GE              reduce using rule 109 (m_exp1 -> empty .)
    LE              reduce using rule 109 (m_exp1 -> empty .)
    EQ              reduce using rule 109 (m_exp1 -> empty .)
    NE              reduce using rule 109 (m_exp1 -> empty .)
    AND             reduce using rule 109 (m_exp1 -> empty .)
    OR              reduce using rule 109 (m_exp1 -> empty .)
    RBRACKET        reduce using rule 109 (m_exp1 -> empty .)
    RPAREN          reduce using rule 109 (m_exp1 -> empty .)
    COMMA           reduce using rule 109 (m_exp1 -> empty .)
    SEMICOL         reduce using rule 109 (m_exp1 -> empty .)


state 74

    (110) term -> factor term1 .

    PLUS            reduce using rule 110 (term -> factor term1 .)
    MINUS           reduce using rule 110 (term -> factor term1 .)
    GT              reduce using rule 110 (term -> factor term1 .)
    LT              reduce using rule 110 (term -> factor term1 .)
    GE              reduce using rule 110 (term -> factor term1 .)
    LE              reduce using rule 110 (term -> factor term1 .)
    EQ              reduce using rule 110 (term -> factor term1 .)
    NE              reduce using rule 110 (term -> factor term1 .)
    AND             reduce using rule 110 (term -> factor term1 .)
    OR              reduce using rule 110 (term -> factor term1 .)
    RBRACKET        reduce using rule 110 (term -> factor term1 .)
    RPAREN          reduce using rule 110 (term -> factor term1 .)
    COMMA           reduce using rule 110 (term -> factor term1 .)
    SEMICOL         reduce using rule 110 (term -> factor term1 .)


state 75

    (111) term1 -> TIMES . term
    (110) term -> . factor term1
    (114) factor -> . LPAREN exp RPAREN
    (115) factor -> . variable
    (116) factor -> . std_func
    (117) factor -> . CTE_INT
    (118) factor -> . CTE_FLOAT
    (30) variable -> . ID variable1
    (59) std_func -> . ID LPAREN std_func1 RPAREN

    LPAREN          shift and go to state 40
    CTE_INT         shift and go to state 43
    CTE_FLOAT       shift and go to state 44
    ID              shift and go to state 33

    term                           shift and go to state 143
    factor                         shift and go to state 39
    variable                       shift and go to state 41
    std_func                       shift and go to state 42

state 76

    (112) term1 -> DIVIDE . term
    (110) term -> . factor term1
    (114) factor -> . LPAREN exp RPAREN
    (115) factor -> . variable
    (116) factor -> . std_func
    (117) factor -> . CTE_INT
    (118) factor -> . CTE_FLOAT
    (30) variable -> . ID variable1
    (59) std_func -> . ID LPAREN std_func1 RPAREN

    LPAREN          shift and go to state 40
    CTE_INT         shift and go to state 43
    CTE_FLOAT       shift and go to state 44
    ID              shift and go to state 33

    term                           shift and go to state 144
    factor                         shift and go to state 39
    variable                       shift and go to state 41
    std_func                       shift and go to state 42

state 77

    (113) term1 -> empty .

    PLUS            reduce using rule 113 (term1 -> empty .)
    MINUS           reduce using rule 113 (term1 -> empty .)
    GT              reduce using rule 113 (term1 -> empty .)
    LT              reduce using rule 113 (term1 -> empty .)
    GE              reduce using rule 113 (term1 -> empty .)
    LE              reduce using rule 113 (term1 -> empty .)
    EQ              reduce using rule 113 (term1 -> empty .)
    NE              reduce using rule 113 (term1 -> empty .)
    AND             reduce using rule 113 (term1 -> empty .)
    OR              reduce using rule 113 (term1 -> empty .)
    RBRACKET        reduce using rule 113 (term1 -> empty .)
    RPAREN          reduce using rule 113 (term1 -> empty .)
    COMMA           reduce using rule 113 (term1 -> empty .)
    SEMICOL         reduce using rule 113 (term1 -> empty .)


state 78

    (114) factor -> LPAREN exp . RPAREN

    RPAREN          shift and go to state 145


state 79

    (8) dec_vars1 -> smp_type ID dec_vars2 SEMICOL dec_vars4 .

    FUNC            reduce using rule 8 (dec_vars1 -> smp_type ID dec_vars2 SEMICOL dec_vars4 .)
    MAIN            reduce using rule 8 (dec_vars1 -> smp_type ID dec_vars2 SEMICOL dec_vars4 .)
    INPUT           reduce using rule 8 (dec_vars1 -> smp_type ID dec_vars2 SEMICOL dec_vars4 .)
    PRINT           reduce using rule 8 (dec_vars1 -> smp_type ID dec_vars2 SEMICOL dec_vars4 .)
    IF              reduce using rule 8 (dec_vars1 -> smp_type ID dec_vars2 SEMICOL dec_vars4 .)
    FOR             reduce using rule 8 (dec_vars1 -> smp_type ID dec_vars2 SEMICOL dec_vars4 .)
    WHILE           reduce using rule 8 (dec_vars1 -> smp_type ID dec_vars2 SEMICOL dec_vars4 .)
    ID              reduce using rule 8 (dec_vars1 -> smp_type ID dec_vars2 SEMICOL dec_vars4 .)
    GENERATE_KEY    reduce using rule 8 (dec_vars1 -> smp_type ID dec_vars2 SEMICOL dec_vars4 .)
    OPEN            reduce using rule 8 (dec_vars1 -> smp_type ID dec_vars2 SEMICOL dec_vars4 .)
    READ            reduce using rule 8 (dec_vars1 -> smp_type ID dec_vars2 SEMICOL dec_vars4 .)
    WRITE           reduce using rule 8 (dec_vars1 -> smp_type ID dec_vars2 SEMICOL dec_vars4 .)
    CLOSE           reduce using rule 8 (dec_vars1 -> smp_type ID dec_vars2 SEMICOL dec_vars4 .)
    ENCRYPT         reduce using rule 8 (dec_vars1 -> smp_type ID dec_vars2 SEMICOL dec_vars4 .)
    DECRYPT         reduce using rule 8 (dec_vars1 -> smp_type ID dec_vars2 SEMICOL dec_vars4 .)
    HASH_SHA256     reduce using rule 8 (dec_vars1 -> smp_type ID dec_vars2 SEMICOL dec_vars4 .)
    HASH_MD5        reduce using rule 8 (dec_vars1 -> smp_type ID dec_vars2 SEMICOL dec_vars4 .)
    RETURN          reduce using rule 8 (dec_vars1 -> smp_type ID dec_vars2 SEMICOL dec_vars4 .)
    RCURLY          reduce using rule 8 (dec_vars1 -> smp_type ID dec_vars2 SEMICOL dec_vars4 .)


state 80

    (14) dec_vars4 -> dec_vars .

    FUNC            reduce using rule 14 (dec_vars4 -> dec_vars .)
    MAIN            reduce using rule 14 (dec_vars4 -> dec_vars .)
    INPUT           reduce using rule 14 (dec_vars4 -> dec_vars .)
    PRINT           reduce using rule 14 (dec_vars4 -> dec_vars .)
    IF              reduce using rule 14 (dec_vars4 -> dec_vars .)
    FOR             reduce using rule 14 (dec_vars4 -> dec_vars .)
    WHILE           reduce using rule 14 (dec_vars4 -> dec_vars .)
    ID              reduce using rule 14 (dec_vars4 -> dec_vars .)
    GENERATE_KEY    reduce using rule 14 (dec_vars4 -> dec_vars .)
    OPEN            reduce using rule 14 (dec_vars4 -> dec_vars .)
    READ            reduce using rule 14 (dec_vars4 -> dec_vars .)
    WRITE           reduce using rule 14 (dec_vars4 -> dec_vars .)
    CLOSE           reduce using rule 14 (dec_vars4 -> dec_vars .)
    ENCRYPT         reduce using rule 14 (dec_vars4 -> dec_vars .)
    DECRYPT         reduce using rule 14 (dec_vars4 -> dec_vars .)
    HASH_SHA256     reduce using rule 14 (dec_vars4 -> dec_vars .)
    HASH_MD5        reduce using rule 14 (dec_vars4 -> dec_vars .)
    RETURN          reduce using rule 14 (dec_vars4 -> dec_vars .)
    RCURLY          reduce using rule 14 (dec_vars4 -> dec_vars .)


state 81

    (15) dec_vars4 -> empty .

    FUNC            reduce using rule 15 (dec_vars4 -> empty .)
    MAIN            reduce using rule 15 (dec_vars4 -> empty .)
    INPUT           reduce using rule 15 (dec_vars4 -> empty .)
    PRINT           reduce using rule 15 (dec_vars4 -> empty .)
    IF              reduce using rule 15 (dec_vars4 -> empty .)
    FOR             reduce using rule 15 (dec_vars4 -> empty .)
    WHILE           reduce using rule 15 (dec_vars4 -> empty .)
    ID              reduce using rule 15 (dec_vars4 -> empty .)
    GENERATE_KEY    reduce using rule 15 (dec_vars4 -> empty .)
    OPEN            reduce using rule 15 (dec_vars4 -> empty .)
    READ            reduce using rule 15 (dec_vars4 -> empty .)
    WRITE           reduce using rule 15 (dec_vars4 -> empty .)
    CLOSE           reduce using rule 15 (dec_vars4 -> empty .)
    ENCRYPT         reduce using rule 15 (dec_vars4 -> empty .)
    DECRYPT         reduce using rule 15 (dec_vars4 -> empty .)
    HASH_SHA256     reduce using rule 15 (dec_vars4 -> empty .)
    HASH_MD5        reduce using rule 15 (dec_vars4 -> empty .)
    RETURN          reduce using rule 15 (dec_vars4 -> empty .)
    RCURLY          reduce using rule 15 (dec_vars4 -> empty .)


state 82

    (10) dec_vars2 -> COMMA ID dec_vars2 .

    SEMICOL         reduce using rule 10 (dec_vars2 -> COMMA ID dec_vars2 .)


state 83

    (9) dec_vars1 -> sp_type ID dec_vars2 SEMICOL dec_vars4 .

    FUNC            reduce using rule 9 (dec_vars1 -> sp_type ID dec_vars2 SEMICOL dec_vars4 .)
    MAIN            reduce using rule 9 (dec_vars1 -> sp_type ID dec_vars2 SEMICOL dec_vars4 .)
    INPUT           reduce using rule 9 (dec_vars1 -> sp_type ID dec_vars2 SEMICOL dec_vars4 .)
    PRINT           reduce using rule 9 (dec_vars1 -> sp_type ID dec_vars2 SEMICOL dec_vars4 .)
    IF              reduce using rule 9 (dec_vars1 -> sp_type ID dec_vars2 SEMICOL dec_vars4 .)
    FOR             reduce using rule 9 (dec_vars1 -> sp_type ID dec_vars2 SEMICOL dec_vars4 .)
    WHILE           reduce using rule 9 (dec_vars1 -> sp_type ID dec_vars2 SEMICOL dec_vars4 .)
    ID              reduce using rule 9 (dec_vars1 -> sp_type ID dec_vars2 SEMICOL dec_vars4 .)
    GENERATE_KEY    reduce using rule 9 (dec_vars1 -> sp_type ID dec_vars2 SEMICOL dec_vars4 .)
    OPEN            reduce using rule 9 (dec_vars1 -> sp_type ID dec_vars2 SEMICOL dec_vars4 .)
    READ            reduce using rule 9 (dec_vars1 -> sp_type ID dec_vars2 SEMICOL dec_vars4 .)
    WRITE           reduce using rule 9 (dec_vars1 -> sp_type ID dec_vars2 SEMICOL dec_vars4 .)
    CLOSE           reduce using rule 9 (dec_vars1 -> sp_type ID dec_vars2 SEMICOL dec_vars4 .)
    ENCRYPT         reduce using rule 9 (dec_vars1 -> sp_type ID dec_vars2 SEMICOL dec_vars4 .)
    DECRYPT         reduce using rule 9 (dec_vars1 -> sp_type ID dec_vars2 SEMICOL dec_vars4 .)
    HASH_SHA256     reduce using rule 9 (dec_vars1 -> sp_type ID dec_vars2 SEMICOL dec_vars4 .)
    HASH_MD5        reduce using rule 9 (dec_vars1 -> sp_type ID dec_vars2 SEMICOL dec_vars4 .)
    RETURN          reduce using rule 9 (dec_vars1 -> sp_type ID dec_vars2 SEMICOL dec_vars4 .)
    RCURLY          reduce using rule 9 (dec_vars1 -> sp_type ID dec_vars2 SEMICOL dec_vars4 .)


state 84

    (1) prog -> prog1 prog2 MAIN LPAREN RPAREN LCURLY block . RCURLY

    RCURLY          shift and go to state 146


state 85

    (28) block -> statement . block
    (28) block -> . statement block
    (29) block -> . empty
    (35) statement -> . assignment
    (36) statement -> . c_input
    (37) statement -> . c_print
    (38) statement -> . condition
    (39) statement -> . for_loop
    (40) statement -> . while_loop
    (41) statement -> . std_func
    (42) statement -> . sp_func
    (119) empty -> .
    (43) assignment -> . variable EQUAL assignment1 SEMICOL
    (46) c_input -> . INPUT variable c_input1 SEMICOL
    (49) c_print -> . PRINT LPAREN c_print1 RPAREN SEMICOL
    (54) condition -> . IF LPAREN exp RPAREN LCURLY block RCURLY condition1
    (57) for_loop -> . FOR ID IN RANGE LPAREN exp COMMA exp RPAREN LCURLY block RCURLY
    (58) while_loop -> . WHILE LPAREN exp RPAREN LCURLY block RCURLY
    (59) std_func -> . ID LPAREN std_func1 RPAREN
    (64) sp_func -> . generate_key_func
    (65) sp_func -> . file_func
    (66) sp_func -> . crypto_func
    (30) variable -> . ID variable1
    (75) generate_key_func -> . GENERATE_KEY LPAREN RPAREN
    (67) file_func -> . open_file
    (68) file_func -> . read_file
    (69) file_func -> . write_file
    (70) file_func -> . close_file
    (71) crypto_func -> . encrypt_func
    (72) crypto_func -> . decrypt_func
    (73) crypto_func -> . hash_sha256
    (74) crypto_func -> . hash_md5
    (76) open_file -> . OPEN LPAREN CTE_CHAR RPAREN
    (77) read_file -> . READ LPAREN ID RPAREN
    (78) write_file -> . WRITE LPAREN CTE_CHAR ID RPAREN
    (79) close_file -> . CLOSE LPAREN ID RPAREN
    (80) encrypt_func -> . ENCRYPT LPAREN encrypt_func1 COMMA ID RPAREN
    (83) decrypt_func -> . DECRYPT LPAREN decrypt_func1 COMMA ID RPAREN
    (86) hash_sha256 -> . HASH_SHA256 LPAREN hash_sha2561 RPAREN
    (89) hash_md5 -> . HASH_MD5 LPAREN hash_md51 RPAREN

    RCURLY          reduce using rule 119 (empty -> .)
    RETURN          reduce using rule 119 (empty -> .)
    INPUT           shift and go to state 96
    PRINT           shift and go to state 97
    IF              shift and go to state 98
    FOR             shift and go to state 99
    WHILE           shift and go to state 101
    ID              shift and go to state 100
    GENERATE_KEY    shift and go to state 105
    OPEN            shift and go to state 114
    READ            shift and go to state 115
    WRITE           shift and go to state 116
    CLOSE           shift and go to state 117
    ENCRYPT         shift and go to state 118
    DECRYPT         shift and go to state 119
    HASH_SHA256     shift and go to state 120
    HASH_MD5        shift and go to state 121

    statement                      shift and go to state 85
    block                          shift and go to state 147
    empty                          shift and go to state 86
    assignment                     shift and go to state 87
    c_input                        shift and go to state 88
    c_print                        shift and go to state 89
    condition                      shift and go to state 90
    for_loop                       shift and go to state 91
    while_loop                     shift and go to state 92
    std_func                       shift and go to state 93
    sp_func                        shift and go to state 94
    variable                       shift and go to state 95
    generate_key_func              shift and go to state 102
    file_func                      shift and go to state 103
    crypto_func                    shift and go to state 104
    open_file                      shift and go to state 106
    read_file                      shift and go to state 107
    write_file                     shift and go to state 108
    close_file                     shift and go to state 109
    encrypt_func                   shift and go to state 110
    decrypt_func                   shift and go to state 111
    hash_sha256                    shift and go to state 112
    hash_md5                       shift and go to state 113

state 86

    (29) block -> empty .

    RCURLY          reduce using rule 29 (block -> empty .)
    RETURN          reduce using rule 29 (block -> empty .)


state 87

    (35) statement -> assignment .

    INPUT           reduce using rule 35 (statement -> assignment .)
    PRINT           reduce using rule 35 (statement -> assignment .)
    IF              reduce using rule 35 (statement -> assignment .)
    FOR             reduce using rule 35 (statement -> assignment .)
    WHILE           reduce using rule 35 (statement -> assignment .)
    ID              reduce using rule 35 (statement -> assignment .)
    GENERATE_KEY    reduce using rule 35 (statement -> assignment .)
    OPEN            reduce using rule 35 (statement -> assignment .)
    READ            reduce using rule 35 (statement -> assignment .)
    WRITE           reduce using rule 35 (statement -> assignment .)
    CLOSE           reduce using rule 35 (statement -> assignment .)
    ENCRYPT         reduce using rule 35 (statement -> assignment .)
    DECRYPT         reduce using rule 35 (statement -> assignment .)
    HASH_SHA256     reduce using rule 35 (statement -> assignment .)
    HASH_MD5        reduce using rule 35 (statement -> assignment .)
    RCURLY          reduce using rule 35 (statement -> assignment .)
    RETURN          reduce using rule 35 (statement -> assignment .)


state 88

    (36) statement -> c_input .

    INPUT           reduce using rule 36 (statement -> c_input .)
    PRINT           reduce using rule 36 (statement -> c_input .)
    IF              reduce using rule 36 (statement -> c_input .)
    FOR             reduce using rule 36 (statement -> c_input .)
    WHILE           reduce using rule 36 (statement -> c_input .)
    ID              reduce using rule 36 (statement -> c_input .)
    GENERATE_KEY    reduce using rule 36 (statement -> c_input .)
    OPEN            reduce using rule 36 (statement -> c_input .)
    READ            reduce using rule 36 (statement -> c_input .)
    WRITE           reduce using rule 36 (statement -> c_input .)
    CLOSE           reduce using rule 36 (statement -> c_input .)
    ENCRYPT         reduce using rule 36 (statement -> c_input .)
    DECRYPT         reduce using rule 36 (statement -> c_input .)
    HASH_SHA256     reduce using rule 36 (statement -> c_input .)
    HASH_MD5        reduce using rule 36 (statement -> c_input .)
    RCURLY          reduce using rule 36 (statement -> c_input .)
    RETURN          reduce using rule 36 (statement -> c_input .)


state 89

    (37) statement -> c_print .

    INPUT           reduce using rule 37 (statement -> c_print .)
    PRINT           reduce using rule 37 (statement -> c_print .)
    IF              reduce using rule 37 (statement -> c_print .)
    FOR             reduce using rule 37 (statement -> c_print .)
    WHILE           reduce using rule 37 (statement -> c_print .)
    ID              reduce using rule 37 (statement -> c_print .)
    GENERATE_KEY    reduce using rule 37 (statement -> c_print .)
    OPEN            reduce using rule 37 (statement -> c_print .)
    READ            reduce using rule 37 (statement -> c_print .)
    WRITE           reduce using rule 37 (statement -> c_print .)
    CLOSE           reduce using rule 37 (statement -> c_print .)
    ENCRYPT         reduce using rule 37 (statement -> c_print .)
    DECRYPT         reduce using rule 37 (statement -> c_print .)
    HASH_SHA256     reduce using rule 37 (statement -> c_print .)
    HASH_MD5        reduce using rule 37 (statement -> c_print .)
    RCURLY          reduce using rule 37 (statement -> c_print .)
    RETURN          reduce using rule 37 (statement -> c_print .)


state 90

    (38) statement -> condition .

    INPUT           reduce using rule 38 (statement -> condition .)
    PRINT           reduce using rule 38 (statement -> condition .)
    IF              reduce using rule 38 (statement -> condition .)
    FOR             reduce using rule 38 (statement -> condition .)
    WHILE           reduce using rule 38 (statement -> condition .)
    ID              reduce using rule 38 (statement -> condition .)
    GENERATE_KEY    reduce using rule 38 (statement -> condition .)
    OPEN            reduce using rule 38 (statement -> condition .)
    READ            reduce using rule 38 (statement -> condition .)
    WRITE           reduce using rule 38 (statement -> condition .)
    CLOSE           reduce using rule 38 (statement -> condition .)
    ENCRYPT         reduce using rule 38 (statement -> condition .)
    DECRYPT         reduce using rule 38 (statement -> condition .)
    HASH_SHA256     reduce using rule 38 (statement -> condition .)
    HASH_MD5        reduce using rule 38 (statement -> condition .)
    RCURLY          reduce using rule 38 (statement -> condition .)
    RETURN          reduce using rule 38 (statement -> condition .)


state 91

    (39) statement -> for_loop .

    INPUT           reduce using rule 39 (statement -> for_loop .)
    PRINT           reduce using rule 39 (statement -> for_loop .)
    IF              reduce using rule 39 (statement -> for_loop .)
    FOR             reduce using rule 39 (statement -> for_loop .)
    WHILE           reduce using rule 39 (statement -> for_loop .)
    ID              reduce using rule 39 (statement -> for_loop .)
    GENERATE_KEY    reduce using rule 39 (statement -> for_loop .)
    OPEN            reduce using rule 39 (statement -> for_loop .)
    READ            reduce using rule 39 (statement -> for_loop .)
    WRITE           reduce using rule 39 (statement -> for_loop .)
    CLOSE           reduce using rule 39 (statement -> for_loop .)
    ENCRYPT         reduce using rule 39 (statement -> for_loop .)
    DECRYPT         reduce using rule 39 (statement -> for_loop .)
    HASH_SHA256     reduce using rule 39 (statement -> for_loop .)
    HASH_MD5        reduce using rule 39 (statement -> for_loop .)
    RCURLY          reduce using rule 39 (statement -> for_loop .)
    RETURN          reduce using rule 39 (statement -> for_loop .)


state 92

    (40) statement -> while_loop .

    INPUT           reduce using rule 40 (statement -> while_loop .)
    PRINT           reduce using rule 40 (statement -> while_loop .)
    IF              reduce using rule 40 (statement -> while_loop .)
    FOR             reduce using rule 40 (statement -> while_loop .)
    WHILE           reduce using rule 40 (statement -> while_loop .)
    ID              reduce using rule 40 (statement -> while_loop .)
    GENERATE_KEY    reduce using rule 40 (statement -> while_loop .)
    OPEN            reduce using rule 40 (statement -> while_loop .)
    READ            reduce using rule 40 (statement -> while_loop .)
    WRITE           reduce using rule 40 (statement -> while_loop .)
    CLOSE           reduce using rule 40 (statement -> while_loop .)
    ENCRYPT         reduce using rule 40 (statement -> while_loop .)
    DECRYPT         reduce using rule 40 (statement -> while_loop .)
    HASH_SHA256     reduce using rule 40 (statement -> while_loop .)
    HASH_MD5        reduce using rule 40 (statement -> while_loop .)
    RCURLY          reduce using rule 40 (statement -> while_loop .)
    RETURN          reduce using rule 40 (statement -> while_loop .)


state 93

    (41) statement -> std_func .

    INPUT           reduce using rule 41 (statement -> std_func .)
    PRINT           reduce using rule 41 (statement -> std_func .)
    IF              reduce using rule 41 (statement -> std_func .)
    FOR             reduce using rule 41 (statement -> std_func .)
    WHILE           reduce using rule 41 (statement -> std_func .)
    ID              reduce using rule 41 (statement -> std_func .)
    GENERATE_KEY    reduce using rule 41 (statement -> std_func .)
    OPEN            reduce using rule 41 (statement -> std_func .)
    READ            reduce using rule 41 (statement -> std_func .)
    WRITE           reduce using rule 41 (statement -> std_func .)
    CLOSE           reduce using rule 41 (statement -> std_func .)
    ENCRYPT         reduce using rule 41 (statement -> std_func .)
    DECRYPT         reduce using rule 41 (statement -> std_func .)
    HASH_SHA256     reduce using rule 41 (statement -> std_func .)
    HASH_MD5        reduce using rule 41 (statement -> std_func .)
    RCURLY          reduce using rule 41 (statement -> std_func .)
    RETURN          reduce using rule 41 (statement -> std_func .)


state 94

    (42) statement -> sp_func .

    INPUT           reduce using rule 42 (statement -> sp_func .)
    PRINT           reduce using rule 42 (statement -> sp_func .)
    IF              reduce using rule 42 (statement -> sp_func .)
    FOR             reduce using rule 42 (statement -> sp_func .)
    WHILE           reduce using rule 42 (statement -> sp_func .)
    ID              reduce using rule 42 (statement -> sp_func .)
    GENERATE_KEY    reduce using rule 42 (statement -> sp_func .)
    OPEN            reduce using rule 42 (statement -> sp_func .)
    READ            reduce using rule 42 (statement -> sp_func .)
    WRITE           reduce using rule 42 (statement -> sp_func .)
    CLOSE           reduce using rule 42 (statement -> sp_func .)
    ENCRYPT         reduce using rule 42 (statement -> sp_func .)
    DECRYPT         reduce using rule 42 (statement -> sp_func .)
    HASH_SHA256     reduce using rule 42 (statement -> sp_func .)
    HASH_MD5        reduce using rule 42 (statement -> sp_func .)
    RCURLY          reduce using rule 42 (statement -> sp_func .)
    RETURN          reduce using rule 42 (statement -> sp_func .)


state 95

    (43) assignment -> variable . EQUAL assignment1 SEMICOL

    EQUAL           shift and go to state 148


state 96

    (46) c_input -> INPUT . variable c_input1 SEMICOL
    (30) variable -> . ID variable1

    ID              shift and go to state 150

    variable                       shift and go to state 149

state 97

    (49) c_print -> PRINT . LPAREN c_print1 RPAREN SEMICOL

    LPAREN          shift and go to state 151


state 98

    (54) condition -> IF . LPAREN exp RPAREN LCURLY block RCURLY condition1

    LPAREN          shift and go to state 152


state 99

    (57) for_loop -> FOR . ID IN RANGE LPAREN exp COMMA exp RPAREN LCURLY block RCURLY

    ID              shift and go to state 153


state 100

    (59) std_func -> ID . LPAREN std_func1 RPAREN
    (30) variable -> ID . variable1
    (31) variable1 -> . LBRACKET exp RBRACKET variable2
    (32) variable1 -> . empty
    (119) empty -> .

    LPAREN          shift and go to state 52
    LBRACKET        shift and go to state 53
    EQUAL           reduce using rule 119 (empty -> .)

    variable1                      shift and go to state 51
    empty                          shift and go to state 54

state 101

    (58) while_loop -> WHILE . LPAREN exp RPAREN LCURLY block RCURLY

    LPAREN          shift and go to state 154


state 102

    (64) sp_func -> generate_key_func .

    INPUT           reduce using rule 64 (sp_func -> generate_key_func .)
    PRINT           reduce using rule 64 (sp_func -> generate_key_func .)
    IF              reduce using rule 64 (sp_func -> generate_key_func .)
    FOR             reduce using rule 64 (sp_func -> generate_key_func .)
    WHILE           reduce using rule 64 (sp_func -> generate_key_func .)
    ID              reduce using rule 64 (sp_func -> generate_key_func .)
    GENERATE_KEY    reduce using rule 64 (sp_func -> generate_key_func .)
    OPEN            reduce using rule 64 (sp_func -> generate_key_func .)
    READ            reduce using rule 64 (sp_func -> generate_key_func .)
    WRITE           reduce using rule 64 (sp_func -> generate_key_func .)
    CLOSE           reduce using rule 64 (sp_func -> generate_key_func .)
    ENCRYPT         reduce using rule 64 (sp_func -> generate_key_func .)
    DECRYPT         reduce using rule 64 (sp_func -> generate_key_func .)
    HASH_SHA256     reduce using rule 64 (sp_func -> generate_key_func .)
    HASH_MD5        reduce using rule 64 (sp_func -> generate_key_func .)
    RCURLY          reduce using rule 64 (sp_func -> generate_key_func .)
    RETURN          reduce using rule 64 (sp_func -> generate_key_func .)
    SEMICOL         reduce using rule 64 (sp_func -> generate_key_func .)


state 103

    (65) sp_func -> file_func .

    INPUT           reduce using rule 65 (sp_func -> file_func .)
    PRINT           reduce using rule 65 (sp_func -> file_func .)
    IF              reduce using rule 65 (sp_func -> file_func .)
    FOR             reduce using rule 65 (sp_func -> file_func .)
    WHILE           reduce using rule 65 (sp_func -> file_func .)
    ID              reduce using rule 65 (sp_func -> file_func .)
    GENERATE_KEY    reduce using rule 65 (sp_func -> file_func .)
    OPEN            reduce using rule 65 (sp_func -> file_func .)
    READ            reduce using rule 65 (sp_func -> file_func .)
    WRITE           reduce using rule 65 (sp_func -> file_func .)
    CLOSE           reduce using rule 65 (sp_func -> file_func .)
    ENCRYPT         reduce using rule 65 (sp_func -> file_func .)
    DECRYPT         reduce using rule 65 (sp_func -> file_func .)
    HASH_SHA256     reduce using rule 65 (sp_func -> file_func .)
    HASH_MD5        reduce using rule 65 (sp_func -> file_func .)
    RCURLY          reduce using rule 65 (sp_func -> file_func .)
    RETURN          reduce using rule 65 (sp_func -> file_func .)
    SEMICOL         reduce using rule 65 (sp_func -> file_func .)


state 104

    (66) sp_func -> crypto_func .

    INPUT           reduce using rule 66 (sp_func -> crypto_func .)
    PRINT           reduce using rule 66 (sp_func -> crypto_func .)
    IF              reduce using rule 66 (sp_func -> crypto_func .)
    FOR             reduce using rule 66 (sp_func -> crypto_func .)
    WHILE           reduce using rule 66 (sp_func -> crypto_func .)
    ID              reduce using rule 66 (sp_func -> crypto_func .)
    GENERATE_KEY    reduce using rule 66 (sp_func -> crypto_func .)
    OPEN            reduce using rule 66 (sp_func -> crypto_func .)
    READ            reduce using rule 66 (sp_func -> crypto_func .)
    WRITE           reduce using rule 66 (sp_func -> crypto_func .)
    CLOSE           reduce using rule 66 (sp_func -> crypto_func .)
    ENCRYPT         reduce using rule 66 (sp_func -> crypto_func .)
    DECRYPT         reduce using rule 66 (sp_func -> crypto_func .)
    HASH_SHA256     reduce using rule 66 (sp_func -> crypto_func .)
    HASH_MD5        reduce using rule 66 (sp_func -> crypto_func .)
    RCURLY          reduce using rule 66 (sp_func -> crypto_func .)
    RETURN          reduce using rule 66 (sp_func -> crypto_func .)
    SEMICOL         reduce using rule 66 (sp_func -> crypto_func .)


state 105

    (75) generate_key_func -> GENERATE_KEY . LPAREN RPAREN

    LPAREN          shift and go to state 155


state 106

    (67) file_func -> open_file .

    INPUT           reduce using rule 67 (file_func -> open_file .)
    PRINT           reduce using rule 67 (file_func -> open_file .)
    IF              reduce using rule 67 (file_func -> open_file .)
    FOR             reduce using rule 67 (file_func -> open_file .)
    WHILE           reduce using rule 67 (file_func -> open_file .)
    ID              reduce using rule 67 (file_func -> open_file .)
    GENERATE_KEY    reduce using rule 67 (file_func -> open_file .)
    OPEN            reduce using rule 67 (file_func -> open_file .)
    READ            reduce using rule 67 (file_func -> open_file .)
    WRITE           reduce using rule 67 (file_func -> open_file .)
    CLOSE           reduce using rule 67 (file_func -> open_file .)
    ENCRYPT         reduce using rule 67 (file_func -> open_file .)
    DECRYPT         reduce using rule 67 (file_func -> open_file .)
    HASH_SHA256     reduce using rule 67 (file_func -> open_file .)
    HASH_MD5        reduce using rule 67 (file_func -> open_file .)
    RCURLY          reduce using rule 67 (file_func -> open_file .)
    RETURN          reduce using rule 67 (file_func -> open_file .)
    SEMICOL         reduce using rule 67 (file_func -> open_file .)


state 107

    (68) file_func -> read_file .

    INPUT           reduce using rule 68 (file_func -> read_file .)
    PRINT           reduce using rule 68 (file_func -> read_file .)
    IF              reduce using rule 68 (file_func -> read_file .)
    FOR             reduce using rule 68 (file_func -> read_file .)
    WHILE           reduce using rule 68 (file_func -> read_file .)
    ID              reduce using rule 68 (file_func -> read_file .)
    GENERATE_KEY    reduce using rule 68 (file_func -> read_file .)
    OPEN            reduce using rule 68 (file_func -> read_file .)
    READ            reduce using rule 68 (file_func -> read_file .)
    WRITE           reduce using rule 68 (file_func -> read_file .)
    CLOSE           reduce using rule 68 (file_func -> read_file .)
    ENCRYPT         reduce using rule 68 (file_func -> read_file .)
    DECRYPT         reduce using rule 68 (file_func -> read_file .)
    HASH_SHA256     reduce using rule 68 (file_func -> read_file .)
    HASH_MD5        reduce using rule 68 (file_func -> read_file .)
    RCURLY          reduce using rule 68 (file_func -> read_file .)
    RETURN          reduce using rule 68 (file_func -> read_file .)
    SEMICOL         reduce using rule 68 (file_func -> read_file .)


state 108

    (69) file_func -> write_file .

    INPUT           reduce using rule 69 (file_func -> write_file .)
    PRINT           reduce using rule 69 (file_func -> write_file .)
    IF              reduce using rule 69 (file_func -> write_file .)
    FOR             reduce using rule 69 (file_func -> write_file .)
    WHILE           reduce using rule 69 (file_func -> write_file .)
    ID              reduce using rule 69 (file_func -> write_file .)
    GENERATE_KEY    reduce using rule 69 (file_func -> write_file .)
    OPEN            reduce using rule 69 (file_func -> write_file .)
    READ            reduce using rule 69 (file_func -> write_file .)
    WRITE           reduce using rule 69 (file_func -> write_file .)
    CLOSE           reduce using rule 69 (file_func -> write_file .)
    ENCRYPT         reduce using rule 69 (file_func -> write_file .)
    DECRYPT         reduce using rule 69 (file_func -> write_file .)
    HASH_SHA256     reduce using rule 69 (file_func -> write_file .)
    HASH_MD5        reduce using rule 69 (file_func -> write_file .)
    RCURLY          reduce using rule 69 (file_func -> write_file .)
    RETURN          reduce using rule 69 (file_func -> write_file .)
    SEMICOL         reduce using rule 69 (file_func -> write_file .)


state 109

    (70) file_func -> close_file .

    INPUT           reduce using rule 70 (file_func -> close_file .)
    PRINT           reduce using rule 70 (file_func -> close_file .)
    IF              reduce using rule 70 (file_func -> close_file .)
    FOR             reduce using rule 70 (file_func -> close_file .)
    WHILE           reduce using rule 70 (file_func -> close_file .)
    ID              reduce using rule 70 (file_func -> close_file .)
    GENERATE_KEY    reduce using rule 70 (file_func -> close_file .)
    OPEN            reduce using rule 70 (file_func -> close_file .)
    READ            reduce using rule 70 (file_func -> close_file .)
    WRITE           reduce using rule 70 (file_func -> close_file .)
    CLOSE           reduce using rule 70 (file_func -> close_file .)
    ENCRYPT         reduce using rule 70 (file_func -> close_file .)
    DECRYPT         reduce using rule 70 (file_func -> close_file .)
    HASH_SHA256     reduce using rule 70 (file_func -> close_file .)
    HASH_MD5        reduce using rule 70 (file_func -> close_file .)
    RCURLY          reduce using rule 70 (file_func -> close_file .)
    RETURN          reduce using rule 70 (file_func -> close_file .)
    SEMICOL         reduce using rule 70 (file_func -> close_file .)


state 110

    (71) crypto_func -> encrypt_func .

    INPUT           reduce using rule 71 (crypto_func -> encrypt_func .)
    PRINT           reduce using rule 71 (crypto_func -> encrypt_func .)
    IF              reduce using rule 71 (crypto_func -> encrypt_func .)
    FOR             reduce using rule 71 (crypto_func -> encrypt_func .)
    WHILE           reduce using rule 71 (crypto_func -> encrypt_func .)
    ID              reduce using rule 71 (crypto_func -> encrypt_func .)
    GENERATE_KEY    reduce using rule 71 (crypto_func -> encrypt_func .)
    OPEN            reduce using rule 71 (crypto_func -> encrypt_func .)
    READ            reduce using rule 71 (crypto_func -> encrypt_func .)
    WRITE           reduce using rule 71 (crypto_func -> encrypt_func .)
    CLOSE           reduce using rule 71 (crypto_func -> encrypt_func .)
    ENCRYPT         reduce using rule 71 (crypto_func -> encrypt_func .)
    DECRYPT         reduce using rule 71 (crypto_func -> encrypt_func .)
    HASH_SHA256     reduce using rule 71 (crypto_func -> encrypt_func .)
    HASH_MD5        reduce using rule 71 (crypto_func -> encrypt_func .)
    RCURLY          reduce using rule 71 (crypto_func -> encrypt_func .)
    RETURN          reduce using rule 71 (crypto_func -> encrypt_func .)
    SEMICOL         reduce using rule 71 (crypto_func -> encrypt_func .)


state 111

    (72) crypto_func -> decrypt_func .

    INPUT           reduce using rule 72 (crypto_func -> decrypt_func .)
    PRINT           reduce using rule 72 (crypto_func -> decrypt_func .)
    IF              reduce using rule 72 (crypto_func -> decrypt_func .)
    FOR             reduce using rule 72 (crypto_func -> decrypt_func .)
    WHILE           reduce using rule 72 (crypto_func -> decrypt_func .)
    ID              reduce using rule 72 (crypto_func -> decrypt_func .)
    GENERATE_KEY    reduce using rule 72 (crypto_func -> decrypt_func .)
    OPEN            reduce using rule 72 (crypto_func -> decrypt_func .)
    READ            reduce using rule 72 (crypto_func -> decrypt_func .)
    WRITE           reduce using rule 72 (crypto_func -> decrypt_func .)
    CLOSE           reduce using rule 72 (crypto_func -> decrypt_func .)
    ENCRYPT         reduce using rule 72 (crypto_func -> decrypt_func .)
    DECRYPT         reduce using rule 72 (crypto_func -> decrypt_func .)
    HASH_SHA256     reduce using rule 72 (crypto_func -> decrypt_func .)
    HASH_MD5        reduce using rule 72 (crypto_func -> decrypt_func .)
    RCURLY          reduce using rule 72 (crypto_func -> decrypt_func .)
    RETURN          reduce using rule 72 (crypto_func -> decrypt_func .)
    SEMICOL         reduce using rule 72 (crypto_func -> decrypt_func .)


state 112

    (73) crypto_func -> hash_sha256 .

    INPUT           reduce using rule 73 (crypto_func -> hash_sha256 .)
    PRINT           reduce using rule 73 (crypto_func -> hash_sha256 .)
    IF              reduce using rule 73 (crypto_func -> hash_sha256 .)
    FOR             reduce using rule 73 (crypto_func -> hash_sha256 .)
    WHILE           reduce using rule 73 (crypto_func -> hash_sha256 .)
    ID              reduce using rule 73 (crypto_func -> hash_sha256 .)
    GENERATE_KEY    reduce using rule 73 (crypto_func -> hash_sha256 .)
    OPEN            reduce using rule 73 (crypto_func -> hash_sha256 .)
    READ            reduce using rule 73 (crypto_func -> hash_sha256 .)
    WRITE           reduce using rule 73 (crypto_func -> hash_sha256 .)
    CLOSE           reduce using rule 73 (crypto_func -> hash_sha256 .)
    ENCRYPT         reduce using rule 73 (crypto_func -> hash_sha256 .)
    DECRYPT         reduce using rule 73 (crypto_func -> hash_sha256 .)
    HASH_SHA256     reduce using rule 73 (crypto_func -> hash_sha256 .)
    HASH_MD5        reduce using rule 73 (crypto_func -> hash_sha256 .)
    RCURLY          reduce using rule 73 (crypto_func -> hash_sha256 .)
    RETURN          reduce using rule 73 (crypto_func -> hash_sha256 .)
    SEMICOL         reduce using rule 73 (crypto_func -> hash_sha256 .)


state 113

    (74) crypto_func -> hash_md5 .

    INPUT           reduce using rule 74 (crypto_func -> hash_md5 .)
    PRINT           reduce using rule 74 (crypto_func -> hash_md5 .)
    IF              reduce using rule 74 (crypto_func -> hash_md5 .)
    FOR             reduce using rule 74 (crypto_func -> hash_md5 .)
    WHILE           reduce using rule 74 (crypto_func -> hash_md5 .)
    ID              reduce using rule 74 (crypto_func -> hash_md5 .)
    GENERATE_KEY    reduce using rule 74 (crypto_func -> hash_md5 .)
    OPEN            reduce using rule 74 (crypto_func -> hash_md5 .)
    READ            reduce using rule 74 (crypto_func -> hash_md5 .)
    WRITE           reduce using rule 74 (crypto_func -> hash_md5 .)
    CLOSE           reduce using rule 74 (crypto_func -> hash_md5 .)
    ENCRYPT         reduce using rule 74 (crypto_func -> hash_md5 .)
    DECRYPT         reduce using rule 74 (crypto_func -> hash_md5 .)
    HASH_SHA256     reduce using rule 74 (crypto_func -> hash_md5 .)
    HASH_MD5        reduce using rule 74 (crypto_func -> hash_md5 .)
    RCURLY          reduce using rule 74 (crypto_func -> hash_md5 .)
    RETURN          reduce using rule 74 (crypto_func -> hash_md5 .)
    SEMICOL         reduce using rule 74 (crypto_func -> hash_md5 .)


state 114

    (76) open_file -> OPEN . LPAREN CTE_CHAR RPAREN

    LPAREN          shift and go to state 156


state 115

    (77) read_file -> READ . LPAREN ID RPAREN

    LPAREN          shift and go to state 157


state 116

    (78) write_file -> WRITE . LPAREN CTE_CHAR ID RPAREN

    LPAREN          shift and go to state 158


state 117

    (79) close_file -> CLOSE . LPAREN ID RPAREN

    LPAREN          shift and go to state 159


state 118

    (80) encrypt_func -> ENCRYPT . LPAREN encrypt_func1 COMMA ID RPAREN

    LPAREN          shift and go to state 160


state 119

    (83) decrypt_func -> DECRYPT . LPAREN decrypt_func1 COMMA ID RPAREN

    LPAREN          shift and go to state 161


state 120

    (86) hash_sha256 -> HASH_SHA256 . LPAREN hash_sha2561 RPAREN

    LPAREN          shift and go to state 162


state 121

    (89) hash_md5 -> HASH_MD5 . LPAREN hash_md51 RPAREN

    LPAREN          shift and go to state 163


state 122

    (20) function -> FUNC ID LPAREN param RPAREN ARROW . smp_type LCURLY function1 block RETURN exp SEMICOL RCURLY
    (21) function -> FUNC ID LPAREN param RPAREN ARROW . VOID LCURLY function1 block RCURLY
    (16) smp_type -> . INT
    (17) smp_type -> . FLOAT
    (18) smp_type -> . CHAR

    VOID            shift and go to state 165
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 15

    smp_type                       shift and go to state 164

state 123

    (24) param -> smp_type ID param1 .

    RPAREN          reduce using rule 24 (param -> smp_type ID param1 .)


state 124

    (26) param1 -> COMMA . smp_type ID param1
    (16) smp_type -> . INT
    (17) smp_type -> . FLOAT
    (18) smp_type -> . CHAR

    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 15

    smp_type                       shift and go to state 166

state 125

    (27) param1 -> empty .

    RPAREN          reduce using rule 27 (param1 -> empty .)


state 126

    (59) std_func -> ID LPAREN std_func1 . RPAREN

    RPAREN          shift and go to state 167


state 127

    (60) std_func1 -> exp . std_func2
    (62) std_func2 -> . COMMA exp std_func2
    (63) std_func2 -> . empty
    (119) empty -> .

    COMMA           shift and go to state 169
    RPAREN          reduce using rule 119 (empty -> .)

    std_func2                      shift and go to state 168
    empty                          shift and go to state 170

state 128

    (61) std_func1 -> empty .

    RPAREN          reduce using rule 61 (std_func1 -> empty .)


state 129

    (31) variable1 -> LBRACKET exp . RBRACKET variable2

    RBRACKET        shift and go to state 171


state 130

    (12) dec_vars3 -> LBRACKET . exp RBRACKET
    (92) exp -> . t_exp exp1
    (95) t_exp -> . g_exp t_exp1
    (98) g_exp -> . m_exp g_exp1
    (106) m_exp -> . term m_exp1
    (110) term -> . factor term1
    (114) factor -> . LPAREN exp RPAREN
    (115) factor -> . variable
    (116) factor -> . std_func
    (117) factor -> . CTE_INT
    (118) factor -> . CTE_FLOAT
    (30) variable -> . ID variable1
    (59) std_func -> . ID LPAREN std_func1 RPAREN

    LPAREN          shift and go to state 40
    CTE_INT         shift and go to state 43
    CTE_FLOAT       shift and go to state 44
    ID              shift and go to state 33

    exp                            shift and go to state 172
    t_exp                          shift and go to state 35
    g_exp                          shift and go to state 36
    m_exp                          shift and go to state 37
    term                           shift and go to state 38
    factor                         shift and go to state 39
    variable                       shift and go to state 41
    std_func                       shift and go to state 42

state 131

    (7) dec_vars1 -> smp_type ID LBRACKET exp RBRACKET dec_vars3 . SEMICOL dec_vars4

    SEMICOL         shift and go to state 173


state 132

    (13) dec_vars3 -> empty .

    SEMICOL         reduce using rule 13 (dec_vars3 -> empty .)


state 133

    (93) exp1 -> OR exp .

    RBRACKET        reduce using rule 93 (exp1 -> OR exp .)
    RPAREN          reduce using rule 93 (exp1 -> OR exp .)
    COMMA           reduce using rule 93 (exp1 -> OR exp .)
    SEMICOL         reduce using rule 93 (exp1 -> OR exp .)


state 134

    (96) t_exp1 -> AND t_exp .

    OR              reduce using rule 96 (t_exp1 -> AND t_exp .)
    RBRACKET        reduce using rule 96 (t_exp1 -> AND t_exp .)
    RPAREN          reduce using rule 96 (t_exp1 -> AND t_exp .)
    COMMA           reduce using rule 96 (t_exp1 -> AND t_exp .)
    SEMICOL         reduce using rule 96 (t_exp1 -> AND t_exp .)


state 135

    (99) g_exp1 -> GT m_exp .

    AND             reduce using rule 99 (g_exp1 -> GT m_exp .)
    OR              reduce using rule 99 (g_exp1 -> GT m_exp .)
    RBRACKET        reduce using rule 99 (g_exp1 -> GT m_exp .)
    RPAREN          reduce using rule 99 (g_exp1 -> GT m_exp .)
    COMMA           reduce using rule 99 (g_exp1 -> GT m_exp .)
    SEMICOL         reduce using rule 99 (g_exp1 -> GT m_exp .)


state 136

    (100) g_exp1 -> LT m_exp .

    AND             reduce using rule 100 (g_exp1 -> LT m_exp .)
    OR              reduce using rule 100 (g_exp1 -> LT m_exp .)
    RBRACKET        reduce using rule 100 (g_exp1 -> LT m_exp .)
    RPAREN          reduce using rule 100 (g_exp1 -> LT m_exp .)
    COMMA           reduce using rule 100 (g_exp1 -> LT m_exp .)
    SEMICOL         reduce using rule 100 (g_exp1 -> LT m_exp .)


state 137

    (101) g_exp1 -> GE m_exp .

    AND             reduce using rule 101 (g_exp1 -> GE m_exp .)
    OR              reduce using rule 101 (g_exp1 -> GE m_exp .)
    RBRACKET        reduce using rule 101 (g_exp1 -> GE m_exp .)
    RPAREN          reduce using rule 101 (g_exp1 -> GE m_exp .)
    COMMA           reduce using rule 101 (g_exp1 -> GE m_exp .)
    SEMICOL         reduce using rule 101 (g_exp1 -> GE m_exp .)


state 138

    (102) g_exp1 -> LE m_exp .

    AND             reduce using rule 102 (g_exp1 -> LE m_exp .)
    OR              reduce using rule 102 (g_exp1 -> LE m_exp .)
    RBRACKET        reduce using rule 102 (g_exp1 -> LE m_exp .)
    RPAREN          reduce using rule 102 (g_exp1 -> LE m_exp .)
    COMMA           reduce using rule 102 (g_exp1 -> LE m_exp .)
    SEMICOL         reduce using rule 102 (g_exp1 -> LE m_exp .)


state 139

    (103) g_exp1 -> EQ m_exp .

    AND             reduce using rule 103 (g_exp1 -> EQ m_exp .)
    OR              reduce using rule 103 (g_exp1 -> EQ m_exp .)
    RBRACKET        reduce using rule 103 (g_exp1 -> EQ m_exp .)
    RPAREN          reduce using rule 103 (g_exp1 -> EQ m_exp .)
    COMMA           reduce using rule 103 (g_exp1 -> EQ m_exp .)
    SEMICOL         reduce using rule 103 (g_exp1 -> EQ m_exp .)


state 140

    (104) g_exp1 -> NE m_exp .

    AND             reduce using rule 104 (g_exp1 -> NE m_exp .)
    OR              reduce using rule 104 (g_exp1 -> NE m_exp .)
    RBRACKET        reduce using rule 104 (g_exp1 -> NE m_exp .)
    RPAREN          reduce using rule 104 (g_exp1 -> NE m_exp .)
    COMMA           reduce using rule 104 (g_exp1 -> NE m_exp .)
    SEMICOL         reduce using rule 104 (g_exp1 -> NE m_exp .)


state 141

    (107) m_exp1 -> PLUS m_exp .

    GT              reduce using rule 107 (m_exp1 -> PLUS m_exp .)
    LT              reduce using rule 107 (m_exp1 -> PLUS m_exp .)
    GE              reduce using rule 107 (m_exp1 -> PLUS m_exp .)
    LE              reduce using rule 107 (m_exp1 -> PLUS m_exp .)
    EQ              reduce using rule 107 (m_exp1 -> PLUS m_exp .)
    NE              reduce using rule 107 (m_exp1 -> PLUS m_exp .)
    AND             reduce using rule 107 (m_exp1 -> PLUS m_exp .)
    OR              reduce using rule 107 (m_exp1 -> PLUS m_exp .)
    RBRACKET        reduce using rule 107 (m_exp1 -> PLUS m_exp .)
    RPAREN          reduce using rule 107 (m_exp1 -> PLUS m_exp .)
    COMMA           reduce using rule 107 (m_exp1 -> PLUS m_exp .)
    SEMICOL         reduce using rule 107 (m_exp1 -> PLUS m_exp .)


state 142

    (108) m_exp1 -> MINUS m_exp .

    GT              reduce using rule 108 (m_exp1 -> MINUS m_exp .)
    LT              reduce using rule 108 (m_exp1 -> MINUS m_exp .)
    GE              reduce using rule 108 (m_exp1 -> MINUS m_exp .)
    LE              reduce using rule 108 (m_exp1 -> MINUS m_exp .)
    EQ              reduce using rule 108 (m_exp1 -> MINUS m_exp .)
    NE              reduce using rule 108 (m_exp1 -> MINUS m_exp .)
    AND             reduce using rule 108 (m_exp1 -> MINUS m_exp .)
    OR              reduce using rule 108 (m_exp1 -> MINUS m_exp .)
    RBRACKET        reduce using rule 108 (m_exp1 -> MINUS m_exp .)
    RPAREN          reduce using rule 108 (m_exp1 -> MINUS m_exp .)
    COMMA           reduce using rule 108 (m_exp1 -> MINUS m_exp .)
    SEMICOL         reduce using rule 108 (m_exp1 -> MINUS m_exp .)


state 143

    (111) term1 -> TIMES term .

    PLUS            reduce using rule 111 (term1 -> TIMES term .)
    MINUS           reduce using rule 111 (term1 -> TIMES term .)
    GT              reduce using rule 111 (term1 -> TIMES term .)
    LT              reduce using rule 111 (term1 -> TIMES term .)
    GE              reduce using rule 111 (term1 -> TIMES term .)
    LE              reduce using rule 111 (term1 -> TIMES term .)
    EQ              reduce using rule 111 (term1 -> TIMES term .)
    NE              reduce using rule 111 (term1 -> TIMES term .)
    AND             reduce using rule 111 (term1 -> TIMES term .)
    OR              reduce using rule 111 (term1 -> TIMES term .)
    RBRACKET        reduce using rule 111 (term1 -> TIMES term .)
    RPAREN          reduce using rule 111 (term1 -> TIMES term .)
    COMMA           reduce using rule 111 (term1 -> TIMES term .)
    SEMICOL         reduce using rule 111 (term1 -> TIMES term .)


state 144

    (112) term1 -> DIVIDE term .

    PLUS            reduce using rule 112 (term1 -> DIVIDE term .)
    MINUS           reduce using rule 112 (term1 -> DIVIDE term .)
    GT              reduce using rule 112 (term1 -> DIVIDE term .)
    LT              reduce using rule 112 (term1 -> DIVIDE term .)
    GE              reduce using rule 112 (term1 -> DIVIDE term .)
    LE              reduce using rule 112 (term1 -> DIVIDE term .)
    EQ              reduce using rule 112 (term1 -> DIVIDE term .)
    NE              reduce using rule 112 (term1 -> DIVIDE term .)
    AND             reduce using rule 112 (term1 -> DIVIDE term .)
    OR              reduce using rule 112 (term1 -> DIVIDE term .)
    RBRACKET        reduce using rule 112 (term1 -> DIVIDE term .)
    RPAREN          reduce using rule 112 (term1 -> DIVIDE term .)
    COMMA           reduce using rule 112 (term1 -> DIVIDE term .)
    SEMICOL         reduce using rule 112 (term1 -> DIVIDE term .)


state 145

    (114) factor -> LPAREN exp RPAREN .

    TIMES           reduce using rule 114 (factor -> LPAREN exp RPAREN .)
    DIVIDE          reduce using rule 114 (factor -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 114 (factor -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 114 (factor -> LPAREN exp RPAREN .)
    GT              reduce using rule 114 (factor -> LPAREN exp RPAREN .)
    LT              reduce using rule 114 (factor -> LPAREN exp RPAREN .)
    GE              reduce using rule 114 (factor -> LPAREN exp RPAREN .)
    LE              reduce using rule 114 (factor -> LPAREN exp RPAREN .)
    EQ              reduce using rule 114 (factor -> LPAREN exp RPAREN .)
    NE              reduce using rule 114 (factor -> LPAREN exp RPAREN .)
    AND             reduce using rule 114 (factor -> LPAREN exp RPAREN .)
    OR              reduce using rule 114 (factor -> LPAREN exp RPAREN .)
    RBRACKET        reduce using rule 114 (factor -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 114 (factor -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 114 (factor -> LPAREN exp RPAREN .)
    SEMICOL         reduce using rule 114 (factor -> LPAREN exp RPAREN .)


state 146

    (1) prog -> prog1 prog2 MAIN LPAREN RPAREN LCURLY block RCURLY .

    $end            reduce using rule 1 (prog -> prog1 prog2 MAIN LPAREN RPAREN LCURLY block RCURLY .)


state 147

    (28) block -> statement block .

    RCURLY          reduce using rule 28 (block -> statement block .)
    RETURN          reduce using rule 28 (block -> statement block .)


state 148

    (43) assignment -> variable EQUAL . assignment1 SEMICOL
    (44) assignment1 -> . exp
    (45) assignment1 -> . sp_func
    (92) exp -> . t_exp exp1
    (64) sp_func -> . generate_key_func
    (65) sp_func -> . file_func
    (66) sp_func -> . crypto_func
    (95) t_exp -> . g_exp t_exp1
    (75) generate_key_func -> . GENERATE_KEY LPAREN RPAREN
    (67) file_func -> . open_file
    (68) file_func -> . read_file
    (69) file_func -> . write_file
    (70) file_func -> . close_file
    (71) crypto_func -> . encrypt_func
    (72) crypto_func -> . decrypt_func
    (73) crypto_func -> . hash_sha256
    (74) crypto_func -> . hash_md5
    (98) g_exp -> . m_exp g_exp1
    (76) open_file -> . OPEN LPAREN CTE_CHAR RPAREN
    (77) read_file -> . READ LPAREN ID RPAREN
    (78) write_file -> . WRITE LPAREN CTE_CHAR ID RPAREN
    (79) close_file -> . CLOSE LPAREN ID RPAREN
    (80) encrypt_func -> . ENCRYPT LPAREN encrypt_func1 COMMA ID RPAREN
    (83) decrypt_func -> . DECRYPT LPAREN decrypt_func1 COMMA ID RPAREN
    (86) hash_sha256 -> . HASH_SHA256 LPAREN hash_sha2561 RPAREN
    (89) hash_md5 -> . HASH_MD5 LPAREN hash_md51 RPAREN
    (106) m_exp -> . term m_exp1
    (110) term -> . factor term1
    (114) factor -> . LPAREN exp RPAREN
    (115) factor -> . variable
    (116) factor -> . std_func
    (117) factor -> . CTE_INT
    (118) factor -> . CTE_FLOAT
    (30) variable -> . ID variable1
    (59) std_func -> . ID LPAREN std_func1 RPAREN

    GENERATE_KEY    shift and go to state 105
    OPEN            shift and go to state 114
    READ            shift and go to state 115
    WRITE           shift and go to state 116
    CLOSE           shift and go to state 117
    ENCRYPT         shift and go to state 118
    DECRYPT         shift and go to state 119
    HASH_SHA256     shift and go to state 120
    HASH_MD5        shift and go to state 121
    LPAREN          shift and go to state 40
    CTE_INT         shift and go to state 43
    CTE_FLOAT       shift and go to state 44
    ID              shift and go to state 33

    variable                       shift and go to state 41
    assignment1                    shift and go to state 174
    exp                            shift and go to state 175
    sp_func                        shift and go to state 176
    t_exp                          shift and go to state 35
    generate_key_func              shift and go to state 102
    file_func                      shift and go to state 103
    crypto_func                    shift and go to state 104
    g_exp                          shift and go to state 36
    open_file                      shift and go to state 106
    read_file                      shift and go to state 107
    write_file                     shift and go to state 108
    close_file                     shift and go to state 109
    encrypt_func                   shift and go to state 110
    decrypt_func                   shift and go to state 111
    hash_sha256                    shift and go to state 112
    hash_md5                       shift and go to state 113
    m_exp                          shift and go to state 37
    term                           shift and go to state 38
    factor                         shift and go to state 39
    std_func                       shift and go to state 42

state 149

    (46) c_input -> INPUT variable . c_input1 SEMICOL
    (47) c_input1 -> . COMMA variable c_input1
    (48) c_input1 -> . empty
    (119) empty -> .

    COMMA           shift and go to state 178
    SEMICOL         reduce using rule 119 (empty -> .)

    c_input1                       shift and go to state 177
    empty                          shift and go to state 179

state 150

    (30) variable -> ID . variable1
    (31) variable1 -> . LBRACKET exp RBRACKET variable2
    (32) variable1 -> . empty
    (119) empty -> .

    LBRACKET        shift and go to state 53
    COMMA           reduce using rule 119 (empty -> .)
    SEMICOL         reduce using rule 119 (empty -> .)

    variable1                      shift and go to state 51
    empty                          shift and go to state 54

state 151

    (49) c_print -> PRINT LPAREN . c_print1 RPAREN SEMICOL
    (50) c_print1 -> . exp c_print2
    (51) c_print1 -> . CTE_CHAR c_print2
    (92) exp -> . t_exp exp1
    (95) t_exp -> . g_exp t_exp1
    (98) g_exp -> . m_exp g_exp1
    (106) m_exp -> . term m_exp1
    (110) term -> . factor term1
    (114) factor -> . LPAREN exp RPAREN
    (115) factor -> . variable
    (116) factor -> . std_func
    (117) factor -> . CTE_INT
    (118) factor -> . CTE_FLOAT
    (30) variable -> . ID variable1
    (59) std_func -> . ID LPAREN std_func1 RPAREN

    CTE_CHAR        shift and go to state 182
    LPAREN          shift and go to state 40
    CTE_INT         shift and go to state 43
    CTE_FLOAT       shift and go to state 44
    ID              shift and go to state 33

    c_print1                       shift and go to state 180
    exp                            shift and go to state 181
    t_exp                          shift and go to state 35
    g_exp                          shift and go to state 36
    m_exp                          shift and go to state 37
    term                           shift and go to state 38
    factor                         shift and go to state 39
    variable                       shift and go to state 41
    std_func                       shift and go to state 42

state 152

    (54) condition -> IF LPAREN . exp RPAREN LCURLY block RCURLY condition1
    (92) exp -> . t_exp exp1
    (95) t_exp -> . g_exp t_exp1
    (98) g_exp -> . m_exp g_exp1
    (106) m_exp -> . term m_exp1
    (110) term -> . factor term1
    (114) factor -> . LPAREN exp RPAREN
    (115) factor -> . variable
    (116) factor -> . std_func
    (117) factor -> . CTE_INT
    (118) factor -> . CTE_FLOAT
    (30) variable -> . ID variable1
    (59) std_func -> . ID LPAREN std_func1 RPAREN

    LPAREN          shift and go to state 40
    CTE_INT         shift and go to state 43
    CTE_FLOAT       shift and go to state 44
    ID              shift and go to state 33

    exp                            shift and go to state 183
    t_exp                          shift and go to state 35
    g_exp                          shift and go to state 36
    m_exp                          shift and go to state 37
    term                           shift and go to state 38
    factor                         shift and go to state 39
    variable                       shift and go to state 41
    std_func                       shift and go to state 42

state 153

    (57) for_loop -> FOR ID . IN RANGE LPAREN exp COMMA exp RPAREN LCURLY block RCURLY

    IN              shift and go to state 184


state 154

    (58) while_loop -> WHILE LPAREN . exp RPAREN LCURLY block RCURLY
    (92) exp -> . t_exp exp1
    (95) t_exp -> . g_exp t_exp1
    (98) g_exp -> . m_exp g_exp1
    (106) m_exp -> . term m_exp1
    (110) term -> . factor term1
    (114) factor -> . LPAREN exp RPAREN
    (115) factor -> . variable
    (116) factor -> . std_func
    (117) factor -> . CTE_INT
    (118) factor -> . CTE_FLOAT
    (30) variable -> . ID variable1
    (59) std_func -> . ID LPAREN std_func1 RPAREN

    LPAREN          shift and go to state 40
    CTE_INT         shift and go to state 43
    CTE_FLOAT       shift and go to state 44
    ID              shift and go to state 33

    exp                            shift and go to state 185
    t_exp                          shift and go to state 35
    g_exp                          shift and go to state 36
    m_exp                          shift and go to state 37
    term                           shift and go to state 38
    factor                         shift and go to state 39
    variable                       shift and go to state 41
    std_func                       shift and go to state 42

state 155

    (75) generate_key_func -> GENERATE_KEY LPAREN . RPAREN

    RPAREN          shift and go to state 186


state 156

    (76) open_file -> OPEN LPAREN . CTE_CHAR RPAREN

    CTE_CHAR        shift and go to state 187


state 157

    (77) read_file -> READ LPAREN . ID RPAREN

    ID              shift and go to state 188


state 158

    (78) write_file -> WRITE LPAREN . CTE_CHAR ID RPAREN

    CTE_CHAR        shift and go to state 189


state 159

    (79) close_file -> CLOSE LPAREN . ID RPAREN

    ID              shift and go to state 190


state 160

    (80) encrypt_func -> ENCRYPT LPAREN . encrypt_func1 COMMA ID RPAREN
    (81) encrypt_func1 -> . CTE_CHAR
    (82) encrypt_func1 -> . ID

    CTE_CHAR        shift and go to state 193
    ID              shift and go to state 192

    encrypt_func1                  shift and go to state 191

state 161

    (83) decrypt_func -> DECRYPT LPAREN . decrypt_func1 COMMA ID RPAREN
    (84) decrypt_func1 -> . CTE_CHAR
    (85) decrypt_func1 -> . ID

    CTE_CHAR        shift and go to state 196
    ID              shift and go to state 195

    decrypt_func1                  shift and go to state 194

state 162

    (86) hash_sha256 -> HASH_SHA256 LPAREN . hash_sha2561 RPAREN
    (87) hash_sha2561 -> . CTE_CHAR
    (88) hash_sha2561 -> . ID

    CTE_CHAR        shift and go to state 198
    ID              shift and go to state 199

    hash_sha2561                   shift and go to state 197

state 163

    (89) hash_md5 -> HASH_MD5 LPAREN . hash_md51 RPAREN
    (90) hash_md51 -> . CTE_CHAR
    (91) hash_md51 -> . ID

    CTE_CHAR        shift and go to state 201
    ID              shift and go to state 202

    hash_md51                      shift and go to state 200

state 164

    (20) function -> FUNC ID LPAREN param RPAREN ARROW smp_type . LCURLY function1 block RETURN exp SEMICOL RCURLY

    LCURLY          shift and go to state 203


state 165

    (21) function -> FUNC ID LPAREN param RPAREN ARROW VOID . LCURLY function1 block RCURLY

    LCURLY          shift and go to state 204


state 166

    (26) param1 -> COMMA smp_type . ID param1

    ID              shift and go to state 205


state 167

    (59) std_func -> ID LPAREN std_func1 RPAREN .

    TIMES           reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)
    DIVIDE          reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)
    PLUS            reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)
    MINUS           reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)
    GT              reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)
    LT              reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)
    GE              reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)
    LE              reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)
    EQ              reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)
    NE              reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)
    AND             reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)
    OR              reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)
    RBRACKET        reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)
    RPAREN          reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)
    INPUT           reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)
    PRINT           reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)
    IF              reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)
    FOR             reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)
    WHILE           reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)
    ID              reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)
    GENERATE_KEY    reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)
    OPEN            reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)
    READ            reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)
    WRITE           reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)
    CLOSE           reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)
    ENCRYPT         reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)
    DECRYPT         reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)
    HASH_SHA256     reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)
    HASH_MD5        reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)
    RCURLY          reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)
    COMMA           reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)
    SEMICOL         reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)
    RETURN          reduce using rule 59 (std_func -> ID LPAREN std_func1 RPAREN .)


state 168

    (60) std_func1 -> exp std_func2 .

    RPAREN          reduce using rule 60 (std_func1 -> exp std_func2 .)


state 169

    (62) std_func2 -> COMMA . exp std_func2
    (92) exp -> . t_exp exp1
    (95) t_exp -> . g_exp t_exp1
    (98) g_exp -> . m_exp g_exp1
    (106) m_exp -> . term m_exp1
    (110) term -> . factor term1
    (114) factor -> . LPAREN exp RPAREN
    (115) factor -> . variable
    (116) factor -> . std_func
    (117) factor -> . CTE_INT
    (118) factor -> . CTE_FLOAT
    (30) variable -> . ID variable1
    (59) std_func -> . ID LPAREN std_func1 RPAREN

    LPAREN          shift and go to state 40
    CTE_INT         shift and go to state 43
    CTE_FLOAT       shift and go to state 44
    ID              shift and go to state 33

    exp                            shift and go to state 206
    t_exp                          shift and go to state 35
    g_exp                          shift and go to state 36
    m_exp                          shift and go to state 37
    term                           shift and go to state 38
    factor                         shift and go to state 39
    variable                       shift and go to state 41
    std_func                       shift and go to state 42

state 170

    (63) std_func2 -> empty .

    RPAREN          reduce using rule 63 (std_func2 -> empty .)


state 171

    (31) variable1 -> LBRACKET exp RBRACKET . variable2
    (33) variable2 -> . LBRACKET exp RBRACKET
    (34) variable2 -> . empty
    (119) empty -> .

    LBRACKET        shift and go to state 207
    TIMES           reduce using rule 119 (empty -> .)
    DIVIDE          reduce using rule 119 (empty -> .)
    PLUS            reduce using rule 119 (empty -> .)
    MINUS           reduce using rule 119 (empty -> .)
    GT              reduce using rule 119 (empty -> .)
    LT              reduce using rule 119 (empty -> .)
    GE              reduce using rule 119 (empty -> .)
    LE              reduce using rule 119 (empty -> .)
    EQ              reduce using rule 119 (empty -> .)
    NE              reduce using rule 119 (empty -> .)
    AND             reduce using rule 119 (empty -> .)
    OR              reduce using rule 119 (empty -> .)
    RBRACKET        reduce using rule 119 (empty -> .)
    RPAREN          reduce using rule 119 (empty -> .)
    COMMA           reduce using rule 119 (empty -> .)
    SEMICOL         reduce using rule 119 (empty -> .)
    EQUAL           reduce using rule 119 (empty -> .)

    variable2                      shift and go to state 208
    empty                          shift and go to state 209

state 172

    (12) dec_vars3 -> LBRACKET exp . RBRACKET

    RBRACKET        shift and go to state 210


state 173

    (7) dec_vars1 -> smp_type ID LBRACKET exp RBRACKET dec_vars3 SEMICOL . dec_vars4
    (14) dec_vars4 -> . dec_vars
    (15) dec_vars4 -> . empty
    (6) dec_vars -> . VAR dec_vars1
    (119) empty -> .

    VAR             shift and go to state 5
    FUNC            reduce using rule 119 (empty -> .)
    MAIN            reduce using rule 119 (empty -> .)
    INPUT           reduce using rule 119 (empty -> .)
    PRINT           reduce using rule 119 (empty -> .)
    IF              reduce using rule 119 (empty -> .)
    FOR             reduce using rule 119 (empty -> .)
    WHILE           reduce using rule 119 (empty -> .)
    ID              reduce using rule 119 (empty -> .)
    GENERATE_KEY    reduce using rule 119 (empty -> .)
    OPEN            reduce using rule 119 (empty -> .)
    READ            reduce using rule 119 (empty -> .)
    WRITE           reduce using rule 119 (empty -> .)
    CLOSE           reduce using rule 119 (empty -> .)
    ENCRYPT         reduce using rule 119 (empty -> .)
    DECRYPT         reduce using rule 119 (empty -> .)
    HASH_SHA256     reduce using rule 119 (empty -> .)
    HASH_MD5        reduce using rule 119 (empty -> .)
    RETURN          reduce using rule 119 (empty -> .)
    RCURLY          reduce using rule 119 (empty -> .)

    dec_vars4                      shift and go to state 211
    dec_vars                       shift and go to state 80
    empty                          shift and go to state 81

state 174

    (43) assignment -> variable EQUAL assignment1 . SEMICOL

    SEMICOL         shift and go to state 212


state 175

    (44) assignment1 -> exp .

    SEMICOL         reduce using rule 44 (assignment1 -> exp .)


state 176

    (45) assignment1 -> sp_func .

    SEMICOL         reduce using rule 45 (assignment1 -> sp_func .)


state 177

    (46) c_input -> INPUT variable c_input1 . SEMICOL

    SEMICOL         shift and go to state 213


state 178

    (47) c_input1 -> COMMA . variable c_input1
    (30) variable -> . ID variable1

    ID              shift and go to state 150

    variable                       shift and go to state 214

state 179

    (48) c_input1 -> empty .

    SEMICOL         reduce using rule 48 (c_input1 -> empty .)


state 180

    (49) c_print -> PRINT LPAREN c_print1 . RPAREN SEMICOL

    RPAREN          shift and go to state 215


state 181

    (50) c_print1 -> exp . c_print2
    (52) c_print2 -> . COMMA c_print1
    (53) c_print2 -> . empty
    (119) empty -> .

    COMMA           shift and go to state 217
    RPAREN          reduce using rule 119 (empty -> .)

    c_print2                       shift and go to state 216
    empty                          shift and go to state 218

state 182

    (51) c_print1 -> CTE_CHAR . c_print2
    (52) c_print2 -> . COMMA c_print1
    (53) c_print2 -> . empty
    (119) empty -> .

    COMMA           shift and go to state 217
    RPAREN          reduce using rule 119 (empty -> .)

    c_print2                       shift and go to state 219
    empty                          shift and go to state 218

state 183

    (54) condition -> IF LPAREN exp . RPAREN LCURLY block RCURLY condition1

    RPAREN          shift and go to state 220


state 184

    (57) for_loop -> FOR ID IN . RANGE LPAREN exp COMMA exp RPAREN LCURLY block RCURLY

    RANGE           shift and go to state 221


state 185

    (58) while_loop -> WHILE LPAREN exp . RPAREN LCURLY block RCURLY

    RPAREN          shift and go to state 222


state 186

    (75) generate_key_func -> GENERATE_KEY LPAREN RPAREN .

    INPUT           reduce using rule 75 (generate_key_func -> GENERATE_KEY LPAREN RPAREN .)
    PRINT           reduce using rule 75 (generate_key_func -> GENERATE_KEY LPAREN RPAREN .)
    IF              reduce using rule 75 (generate_key_func -> GENERATE_KEY LPAREN RPAREN .)
    FOR             reduce using rule 75 (generate_key_func -> GENERATE_KEY LPAREN RPAREN .)
    WHILE           reduce using rule 75 (generate_key_func -> GENERATE_KEY LPAREN RPAREN .)
    ID              reduce using rule 75 (generate_key_func -> GENERATE_KEY LPAREN RPAREN .)
    GENERATE_KEY    reduce using rule 75 (generate_key_func -> GENERATE_KEY LPAREN RPAREN .)
    OPEN            reduce using rule 75 (generate_key_func -> GENERATE_KEY LPAREN RPAREN .)
    READ            reduce using rule 75 (generate_key_func -> GENERATE_KEY LPAREN RPAREN .)
    WRITE           reduce using rule 75 (generate_key_func -> GENERATE_KEY LPAREN RPAREN .)
    CLOSE           reduce using rule 75 (generate_key_func -> GENERATE_KEY LPAREN RPAREN .)
    ENCRYPT         reduce using rule 75 (generate_key_func -> GENERATE_KEY LPAREN RPAREN .)
    DECRYPT         reduce using rule 75 (generate_key_func -> GENERATE_KEY LPAREN RPAREN .)
    HASH_SHA256     reduce using rule 75 (generate_key_func -> GENERATE_KEY LPAREN RPAREN .)
    HASH_MD5        reduce using rule 75 (generate_key_func -> GENERATE_KEY LPAREN RPAREN .)
    RCURLY          reduce using rule 75 (generate_key_func -> GENERATE_KEY LPAREN RPAREN .)
    RETURN          reduce using rule 75 (generate_key_func -> GENERATE_KEY LPAREN RPAREN .)
    SEMICOL         reduce using rule 75 (generate_key_func -> GENERATE_KEY LPAREN RPAREN .)


state 187

    (76) open_file -> OPEN LPAREN CTE_CHAR . RPAREN

    RPAREN          shift and go to state 223


state 188

    (77) read_file -> READ LPAREN ID . RPAREN

    RPAREN          shift and go to state 224


state 189

    (78) write_file -> WRITE LPAREN CTE_CHAR . ID RPAREN

    ID              shift and go to state 225


state 190

    (79) close_file -> CLOSE LPAREN ID . RPAREN

    RPAREN          shift and go to state 226


state 191

    (80) encrypt_func -> ENCRYPT LPAREN encrypt_func1 . COMMA ID RPAREN

    COMMA           shift and go to state 227


state 192

    (82) encrypt_func1 -> ID .

    COMMA           reduce using rule 82 (encrypt_func1 -> ID .)


state 193

    (81) encrypt_func1 -> CTE_CHAR .

    COMMA           reduce using rule 81 (encrypt_func1 -> CTE_CHAR .)


state 194

    (83) decrypt_func -> DECRYPT LPAREN decrypt_func1 . COMMA ID RPAREN

    COMMA           shift and go to state 228


state 195

    (85) decrypt_func1 -> ID .

    COMMA           reduce using rule 85 (decrypt_func1 -> ID .)


state 196

    (84) decrypt_func1 -> CTE_CHAR .

    COMMA           reduce using rule 84 (decrypt_func1 -> CTE_CHAR .)


state 197

    (86) hash_sha256 -> HASH_SHA256 LPAREN hash_sha2561 . RPAREN

    RPAREN          shift and go to state 229


state 198

    (87) hash_sha2561 -> CTE_CHAR .

    RPAREN          reduce using rule 87 (hash_sha2561 -> CTE_CHAR .)


state 199

    (88) hash_sha2561 -> ID .

    RPAREN          reduce using rule 88 (hash_sha2561 -> ID .)


state 200

    (89) hash_md5 -> HASH_MD5 LPAREN hash_md51 . RPAREN

    RPAREN          shift and go to state 230


state 201

    (90) hash_md51 -> CTE_CHAR .

    RPAREN          reduce using rule 90 (hash_md51 -> CTE_CHAR .)


state 202

    (91) hash_md51 -> ID .

    RPAREN          reduce using rule 91 (hash_md51 -> ID .)


state 203

    (20) function -> FUNC ID LPAREN param RPAREN ARROW smp_type LCURLY . function1 block RETURN exp SEMICOL RCURLY
    (22) function1 -> . dec_vars
    (23) function1 -> . empty
    (6) dec_vars -> . VAR dec_vars1
    (119) empty -> .

    VAR             shift and go to state 5
    INPUT           reduce using rule 119 (empty -> .)
    PRINT           reduce using rule 119 (empty -> .)
    IF              reduce using rule 119 (empty -> .)
    FOR             reduce using rule 119 (empty -> .)
    WHILE           reduce using rule 119 (empty -> .)
    ID              reduce using rule 119 (empty -> .)
    GENERATE_KEY    reduce using rule 119 (empty -> .)
    OPEN            reduce using rule 119 (empty -> .)
    READ            reduce using rule 119 (empty -> .)
    WRITE           reduce using rule 119 (empty -> .)
    CLOSE           reduce using rule 119 (empty -> .)
    ENCRYPT         reduce using rule 119 (empty -> .)
    DECRYPT         reduce using rule 119 (empty -> .)
    HASH_SHA256     reduce using rule 119 (empty -> .)
    HASH_MD5        reduce using rule 119 (empty -> .)
    RETURN          reduce using rule 119 (empty -> .)

    function1                      shift and go to state 231
    dec_vars                       shift and go to state 232
    empty                          shift and go to state 233

state 204

    (21) function -> FUNC ID LPAREN param RPAREN ARROW VOID LCURLY . function1 block RCURLY
    (22) function1 -> . dec_vars
    (23) function1 -> . empty
    (6) dec_vars -> . VAR dec_vars1
    (119) empty -> .

    VAR             shift and go to state 5
    INPUT           reduce using rule 119 (empty -> .)
    PRINT           reduce using rule 119 (empty -> .)
    IF              reduce using rule 119 (empty -> .)
    FOR             reduce using rule 119 (empty -> .)
    WHILE           reduce using rule 119 (empty -> .)
    ID              reduce using rule 119 (empty -> .)
    GENERATE_KEY    reduce using rule 119 (empty -> .)
    OPEN            reduce using rule 119 (empty -> .)
    READ            reduce using rule 119 (empty -> .)
    WRITE           reduce using rule 119 (empty -> .)
    CLOSE           reduce using rule 119 (empty -> .)
    ENCRYPT         reduce using rule 119 (empty -> .)
    DECRYPT         reduce using rule 119 (empty -> .)
    HASH_SHA256     reduce using rule 119 (empty -> .)
    HASH_MD5        reduce using rule 119 (empty -> .)
    RCURLY          reduce using rule 119 (empty -> .)

    function1                      shift and go to state 234
    dec_vars                       shift and go to state 232
    empty                          shift and go to state 233

state 205

    (26) param1 -> COMMA smp_type ID . param1
    (26) param1 -> . COMMA smp_type ID param1
    (27) param1 -> . empty
    (119) empty -> .

    COMMA           shift and go to state 124
    RPAREN          reduce using rule 119 (empty -> .)

    param1                         shift and go to state 235
    empty                          shift and go to state 125

state 206

    (62) std_func2 -> COMMA exp . std_func2
    (62) std_func2 -> . COMMA exp std_func2
    (63) std_func2 -> . empty
    (119) empty -> .

    COMMA           shift and go to state 169
    RPAREN          reduce using rule 119 (empty -> .)

    std_func2                      shift and go to state 236
    empty                          shift and go to state 170

state 207

    (33) variable2 -> LBRACKET . exp RBRACKET
    (92) exp -> . t_exp exp1
    (95) t_exp -> . g_exp t_exp1
    (98) g_exp -> . m_exp g_exp1
    (106) m_exp -> . term m_exp1
    (110) term -> . factor term1
    (114) factor -> . LPAREN exp RPAREN
    (115) factor -> . variable
    (116) factor -> . std_func
    (117) factor -> . CTE_INT
    (118) factor -> . CTE_FLOAT
    (30) variable -> . ID variable1
    (59) std_func -> . ID LPAREN std_func1 RPAREN

    LPAREN          shift and go to state 40
    CTE_INT         shift and go to state 43
    CTE_FLOAT       shift and go to state 44
    ID              shift and go to state 33

    exp                            shift and go to state 237
    t_exp                          shift and go to state 35
    g_exp                          shift and go to state 36
    m_exp                          shift and go to state 37
    term                           shift and go to state 38
    factor                         shift and go to state 39
    variable                       shift and go to state 41
    std_func                       shift and go to state 42

state 208

    (31) variable1 -> LBRACKET exp RBRACKET variable2 .

    TIMES           reduce using rule 31 (variable1 -> LBRACKET exp RBRACKET variable2 .)
    DIVIDE          reduce using rule 31 (variable1 -> LBRACKET exp RBRACKET variable2 .)
    PLUS            reduce using rule 31 (variable1 -> LBRACKET exp RBRACKET variable2 .)
    MINUS           reduce using rule 31 (variable1 -> LBRACKET exp RBRACKET variable2 .)
    GT              reduce using rule 31 (variable1 -> LBRACKET exp RBRACKET variable2 .)
    LT              reduce using rule 31 (variable1 -> LBRACKET exp RBRACKET variable2 .)
    GE              reduce using rule 31 (variable1 -> LBRACKET exp RBRACKET variable2 .)
    LE              reduce using rule 31 (variable1 -> LBRACKET exp RBRACKET variable2 .)
    EQ              reduce using rule 31 (variable1 -> LBRACKET exp RBRACKET variable2 .)
    NE              reduce using rule 31 (variable1 -> LBRACKET exp RBRACKET variable2 .)
    AND             reduce using rule 31 (variable1 -> LBRACKET exp RBRACKET variable2 .)
    OR              reduce using rule 31 (variable1 -> LBRACKET exp RBRACKET variable2 .)
    RBRACKET        reduce using rule 31 (variable1 -> LBRACKET exp RBRACKET variable2 .)
    RPAREN          reduce using rule 31 (variable1 -> LBRACKET exp RBRACKET variable2 .)
    COMMA           reduce using rule 31 (variable1 -> LBRACKET exp RBRACKET variable2 .)
    SEMICOL         reduce using rule 31 (variable1 -> LBRACKET exp RBRACKET variable2 .)
    EQUAL           reduce using rule 31 (variable1 -> LBRACKET exp RBRACKET variable2 .)


state 209

    (34) variable2 -> empty .

    TIMES           reduce using rule 34 (variable2 -> empty .)
    DIVIDE          reduce using rule 34 (variable2 -> empty .)
    PLUS            reduce using rule 34 (variable2 -> empty .)
    MINUS           reduce using rule 34 (variable2 -> empty .)
    GT              reduce using rule 34 (variable2 -> empty .)
    LT              reduce using rule 34 (variable2 -> empty .)
    GE              reduce using rule 34 (variable2 -> empty .)
    LE              reduce using rule 34 (variable2 -> empty .)
    EQ              reduce using rule 34 (variable2 -> empty .)
    NE              reduce using rule 34 (variable2 -> empty .)
    AND             reduce using rule 34 (variable2 -> empty .)
    OR              reduce using rule 34 (variable2 -> empty .)
    RBRACKET        reduce using rule 34 (variable2 -> empty .)
    RPAREN          reduce using rule 34 (variable2 -> empty .)
    COMMA           reduce using rule 34 (variable2 -> empty .)
    SEMICOL         reduce using rule 34 (variable2 -> empty .)
    EQUAL           reduce using rule 34 (variable2 -> empty .)


state 210

    (12) dec_vars3 -> LBRACKET exp RBRACKET .

    SEMICOL         reduce using rule 12 (dec_vars3 -> LBRACKET exp RBRACKET .)


state 211

    (7) dec_vars1 -> smp_type ID LBRACKET exp RBRACKET dec_vars3 SEMICOL dec_vars4 .

    FUNC            reduce using rule 7 (dec_vars1 -> smp_type ID LBRACKET exp RBRACKET dec_vars3 SEMICOL dec_vars4 .)
    MAIN            reduce using rule 7 (dec_vars1 -> smp_type ID LBRACKET exp RBRACKET dec_vars3 SEMICOL dec_vars4 .)
    INPUT           reduce using rule 7 (dec_vars1 -> smp_type ID LBRACKET exp RBRACKET dec_vars3 SEMICOL dec_vars4 .)
    PRINT           reduce using rule 7 (dec_vars1 -> smp_type ID LBRACKET exp RBRACKET dec_vars3 SEMICOL dec_vars4 .)
    IF              reduce using rule 7 (dec_vars1 -> smp_type ID LBRACKET exp RBRACKET dec_vars3 SEMICOL dec_vars4 .)
    FOR             reduce using rule 7 (dec_vars1 -> smp_type ID LBRACKET exp RBRACKET dec_vars3 SEMICOL dec_vars4 .)
    WHILE           reduce using rule 7 (dec_vars1 -> smp_type ID LBRACKET exp RBRACKET dec_vars3 SEMICOL dec_vars4 .)
    ID              reduce using rule 7 (dec_vars1 -> smp_type ID LBRACKET exp RBRACKET dec_vars3 SEMICOL dec_vars4 .)
    GENERATE_KEY    reduce using rule 7 (dec_vars1 -> smp_type ID LBRACKET exp RBRACKET dec_vars3 SEMICOL dec_vars4 .)
    OPEN            reduce using rule 7 (dec_vars1 -> smp_type ID LBRACKET exp RBRACKET dec_vars3 SEMICOL dec_vars4 .)
    READ            reduce using rule 7 (dec_vars1 -> smp_type ID LBRACKET exp RBRACKET dec_vars3 SEMICOL dec_vars4 .)
    WRITE           reduce using rule 7 (dec_vars1 -> smp_type ID LBRACKET exp RBRACKET dec_vars3 SEMICOL dec_vars4 .)
    CLOSE           reduce using rule 7 (dec_vars1 -> smp_type ID LBRACKET exp RBRACKET dec_vars3 SEMICOL dec_vars4 .)
    ENCRYPT         reduce using rule 7 (dec_vars1 -> smp_type ID LBRACKET exp RBRACKET dec_vars3 SEMICOL dec_vars4 .)
    DECRYPT         reduce using rule 7 (dec_vars1 -> smp_type ID LBRACKET exp RBRACKET dec_vars3 SEMICOL dec_vars4 .)
    HASH_SHA256     reduce using rule 7 (dec_vars1 -> smp_type ID LBRACKET exp RBRACKET dec_vars3 SEMICOL dec_vars4 .)
    HASH_MD5        reduce using rule 7 (dec_vars1 -> smp_type ID LBRACKET exp RBRACKET dec_vars3 SEMICOL dec_vars4 .)
    RETURN          reduce using rule 7 (dec_vars1 -> smp_type ID LBRACKET exp RBRACKET dec_vars3 SEMICOL dec_vars4 .)
    RCURLY          reduce using rule 7 (dec_vars1 -> smp_type ID LBRACKET exp RBRACKET dec_vars3 SEMICOL dec_vars4 .)


state 212

    (43) assignment -> variable EQUAL assignment1 SEMICOL .

    INPUT           reduce using rule 43 (assignment -> variable EQUAL assignment1 SEMICOL .)
    PRINT           reduce using rule 43 (assignment -> variable EQUAL assignment1 SEMICOL .)
    IF              reduce using rule 43 (assignment -> variable EQUAL assignment1 SEMICOL .)
    FOR             reduce using rule 43 (assignment -> variable EQUAL assignment1 SEMICOL .)
    WHILE           reduce using rule 43 (assignment -> variable EQUAL assignment1 SEMICOL .)
    ID              reduce using rule 43 (assignment -> variable EQUAL assignment1 SEMICOL .)
    GENERATE_KEY    reduce using rule 43 (assignment -> variable EQUAL assignment1 SEMICOL .)
    OPEN            reduce using rule 43 (assignment -> variable EQUAL assignment1 SEMICOL .)
    READ            reduce using rule 43 (assignment -> variable EQUAL assignment1 SEMICOL .)
    WRITE           reduce using rule 43 (assignment -> variable EQUAL assignment1 SEMICOL .)
    CLOSE           reduce using rule 43 (assignment -> variable EQUAL assignment1 SEMICOL .)
    ENCRYPT         reduce using rule 43 (assignment -> variable EQUAL assignment1 SEMICOL .)
    DECRYPT         reduce using rule 43 (assignment -> variable EQUAL assignment1 SEMICOL .)
    HASH_SHA256     reduce using rule 43 (assignment -> variable EQUAL assignment1 SEMICOL .)
    HASH_MD5        reduce using rule 43 (assignment -> variable EQUAL assignment1 SEMICOL .)
    RCURLY          reduce using rule 43 (assignment -> variable EQUAL assignment1 SEMICOL .)
    RETURN          reduce using rule 43 (assignment -> variable EQUAL assignment1 SEMICOL .)


state 213

    (46) c_input -> INPUT variable c_input1 SEMICOL .

    INPUT           reduce using rule 46 (c_input -> INPUT variable c_input1 SEMICOL .)
    PRINT           reduce using rule 46 (c_input -> INPUT variable c_input1 SEMICOL .)
    IF              reduce using rule 46 (c_input -> INPUT variable c_input1 SEMICOL .)
    FOR             reduce using rule 46 (c_input -> INPUT variable c_input1 SEMICOL .)
    WHILE           reduce using rule 46 (c_input -> INPUT variable c_input1 SEMICOL .)
    ID              reduce using rule 46 (c_input -> INPUT variable c_input1 SEMICOL .)
    GENERATE_KEY    reduce using rule 46 (c_input -> INPUT variable c_input1 SEMICOL .)
    OPEN            reduce using rule 46 (c_input -> INPUT variable c_input1 SEMICOL .)
    READ            reduce using rule 46 (c_input -> INPUT variable c_input1 SEMICOL .)
    WRITE           reduce using rule 46 (c_input -> INPUT variable c_input1 SEMICOL .)
    CLOSE           reduce using rule 46 (c_input -> INPUT variable c_input1 SEMICOL .)
    ENCRYPT         reduce using rule 46 (c_input -> INPUT variable c_input1 SEMICOL .)
    DECRYPT         reduce using rule 46 (c_input -> INPUT variable c_input1 SEMICOL .)
    HASH_SHA256     reduce using rule 46 (c_input -> INPUT variable c_input1 SEMICOL .)
    HASH_MD5        reduce using rule 46 (c_input -> INPUT variable c_input1 SEMICOL .)
    RCURLY          reduce using rule 46 (c_input -> INPUT variable c_input1 SEMICOL .)
    RETURN          reduce using rule 46 (c_input -> INPUT variable c_input1 SEMICOL .)


state 214

    (47) c_input1 -> COMMA variable . c_input1
    (47) c_input1 -> . COMMA variable c_input1
    (48) c_input1 -> . empty
    (119) empty -> .

    COMMA           shift and go to state 178
    SEMICOL         reduce using rule 119 (empty -> .)

    c_input1                       shift and go to state 238
    empty                          shift and go to state 179

state 215

    (49) c_print -> PRINT LPAREN c_print1 RPAREN . SEMICOL

    SEMICOL         shift and go to state 239


state 216

    (50) c_print1 -> exp c_print2 .

    RPAREN          reduce using rule 50 (c_print1 -> exp c_print2 .)


state 217

    (52) c_print2 -> COMMA . c_print1
    (50) c_print1 -> . exp c_print2
    (51) c_print1 -> . CTE_CHAR c_print2
    (92) exp -> . t_exp exp1
    (95) t_exp -> . g_exp t_exp1
    (98) g_exp -> . m_exp g_exp1
    (106) m_exp -> . term m_exp1
    (110) term -> . factor term1
    (114) factor -> . LPAREN exp RPAREN
    (115) factor -> . variable
    (116) factor -> . std_func
    (117) factor -> . CTE_INT
    (118) factor -> . CTE_FLOAT
    (30) variable -> . ID variable1
    (59) std_func -> . ID LPAREN std_func1 RPAREN

    CTE_CHAR        shift and go to state 182
    LPAREN          shift and go to state 40
    CTE_INT         shift and go to state 43
    CTE_FLOAT       shift and go to state 44
    ID              shift and go to state 33

    c_print1                       shift and go to state 240
    exp                            shift and go to state 181
    t_exp                          shift and go to state 35
    g_exp                          shift and go to state 36
    m_exp                          shift and go to state 37
    term                           shift and go to state 38
    factor                         shift and go to state 39
    variable                       shift and go to state 41
    std_func                       shift and go to state 42

state 218

    (53) c_print2 -> empty .

    RPAREN          reduce using rule 53 (c_print2 -> empty .)


state 219

    (51) c_print1 -> CTE_CHAR c_print2 .

    RPAREN          reduce using rule 51 (c_print1 -> CTE_CHAR c_print2 .)


state 220

    (54) condition -> IF LPAREN exp RPAREN . LCURLY block RCURLY condition1

    LCURLY          shift and go to state 241


state 221

    (57) for_loop -> FOR ID IN RANGE . LPAREN exp COMMA exp RPAREN LCURLY block RCURLY

    LPAREN          shift and go to state 242


state 222

    (58) while_loop -> WHILE LPAREN exp RPAREN . LCURLY block RCURLY

    LCURLY          shift and go to state 243


state 223

    (76) open_file -> OPEN LPAREN CTE_CHAR RPAREN .

    INPUT           reduce using rule 76 (open_file -> OPEN LPAREN CTE_CHAR RPAREN .)
    PRINT           reduce using rule 76 (open_file -> OPEN LPAREN CTE_CHAR RPAREN .)
    IF              reduce using rule 76 (open_file -> OPEN LPAREN CTE_CHAR RPAREN .)
    FOR             reduce using rule 76 (open_file -> OPEN LPAREN CTE_CHAR RPAREN .)
    WHILE           reduce using rule 76 (open_file -> OPEN LPAREN CTE_CHAR RPAREN .)
    ID              reduce using rule 76 (open_file -> OPEN LPAREN CTE_CHAR RPAREN .)
    GENERATE_KEY    reduce using rule 76 (open_file -> OPEN LPAREN CTE_CHAR RPAREN .)
    OPEN            reduce using rule 76 (open_file -> OPEN LPAREN CTE_CHAR RPAREN .)
    READ            reduce using rule 76 (open_file -> OPEN LPAREN CTE_CHAR RPAREN .)
    WRITE           reduce using rule 76 (open_file -> OPEN LPAREN CTE_CHAR RPAREN .)
    CLOSE           reduce using rule 76 (open_file -> OPEN LPAREN CTE_CHAR RPAREN .)
    ENCRYPT         reduce using rule 76 (open_file -> OPEN LPAREN CTE_CHAR RPAREN .)
    DECRYPT         reduce using rule 76 (open_file -> OPEN LPAREN CTE_CHAR RPAREN .)
    HASH_SHA256     reduce using rule 76 (open_file -> OPEN LPAREN CTE_CHAR RPAREN .)
    HASH_MD5        reduce using rule 76 (open_file -> OPEN LPAREN CTE_CHAR RPAREN .)
    RCURLY          reduce using rule 76 (open_file -> OPEN LPAREN CTE_CHAR RPAREN .)
    RETURN          reduce using rule 76 (open_file -> OPEN LPAREN CTE_CHAR RPAREN .)
    SEMICOL         reduce using rule 76 (open_file -> OPEN LPAREN CTE_CHAR RPAREN .)


state 224

    (77) read_file -> READ LPAREN ID RPAREN .

    INPUT           reduce using rule 77 (read_file -> READ LPAREN ID RPAREN .)
    PRINT           reduce using rule 77 (read_file -> READ LPAREN ID RPAREN .)
    IF              reduce using rule 77 (read_file -> READ LPAREN ID RPAREN .)
    FOR             reduce using rule 77 (read_file -> READ LPAREN ID RPAREN .)
    WHILE           reduce using rule 77 (read_file -> READ LPAREN ID RPAREN .)
    ID              reduce using rule 77 (read_file -> READ LPAREN ID RPAREN .)
    GENERATE_KEY    reduce using rule 77 (read_file -> READ LPAREN ID RPAREN .)
    OPEN            reduce using rule 77 (read_file -> READ LPAREN ID RPAREN .)
    READ            reduce using rule 77 (read_file -> READ LPAREN ID RPAREN .)
    WRITE           reduce using rule 77 (read_file -> READ LPAREN ID RPAREN .)
    CLOSE           reduce using rule 77 (read_file -> READ LPAREN ID RPAREN .)
    ENCRYPT         reduce using rule 77 (read_file -> READ LPAREN ID RPAREN .)
    DECRYPT         reduce using rule 77 (read_file -> READ LPAREN ID RPAREN .)
    HASH_SHA256     reduce using rule 77 (read_file -> READ LPAREN ID RPAREN .)
    HASH_MD5        reduce using rule 77 (read_file -> READ LPAREN ID RPAREN .)
    RCURLY          reduce using rule 77 (read_file -> READ LPAREN ID RPAREN .)
    RETURN          reduce using rule 77 (read_file -> READ LPAREN ID RPAREN .)
    SEMICOL         reduce using rule 77 (read_file -> READ LPAREN ID RPAREN .)


state 225

    (78) write_file -> WRITE LPAREN CTE_CHAR ID . RPAREN

    RPAREN          shift and go to state 244


state 226

    (79) close_file -> CLOSE LPAREN ID RPAREN .

    INPUT           reduce using rule 79 (close_file -> CLOSE LPAREN ID RPAREN .)
    PRINT           reduce using rule 79 (close_file -> CLOSE LPAREN ID RPAREN .)
    IF              reduce using rule 79 (close_file -> CLOSE LPAREN ID RPAREN .)
    FOR             reduce using rule 79 (close_file -> CLOSE LPAREN ID RPAREN .)
    WHILE           reduce using rule 79 (close_file -> CLOSE LPAREN ID RPAREN .)
    ID              reduce using rule 79 (close_file -> CLOSE LPAREN ID RPAREN .)
    GENERATE_KEY    reduce using rule 79 (close_file -> CLOSE LPAREN ID RPAREN .)
    OPEN            reduce using rule 79 (close_file -> CLOSE LPAREN ID RPAREN .)
    READ            reduce using rule 79 (close_file -> CLOSE LPAREN ID RPAREN .)
    WRITE           reduce using rule 79 (close_file -> CLOSE LPAREN ID RPAREN .)
    CLOSE           reduce using rule 79 (close_file -> CLOSE LPAREN ID RPAREN .)
    ENCRYPT         reduce using rule 79 (close_file -> CLOSE LPAREN ID RPAREN .)
    DECRYPT         reduce using rule 79 (close_file -> CLOSE LPAREN ID RPAREN .)
    HASH_SHA256     reduce using rule 79 (close_file -> CLOSE LPAREN ID RPAREN .)
    HASH_MD5        reduce using rule 79 (close_file -> CLOSE LPAREN ID RPAREN .)
    RCURLY          reduce using rule 79 (close_file -> CLOSE LPAREN ID RPAREN .)
    RETURN          reduce using rule 79 (close_file -> CLOSE LPAREN ID RPAREN .)
    SEMICOL         reduce using rule 79 (close_file -> CLOSE LPAREN ID RPAREN .)


state 227

    (80) encrypt_func -> ENCRYPT LPAREN encrypt_func1 COMMA . ID RPAREN

    ID              shift and go to state 245


state 228

    (83) decrypt_func -> DECRYPT LPAREN decrypt_func1 COMMA . ID RPAREN

    ID              shift and go to state 246


state 229

    (86) hash_sha256 -> HASH_SHA256 LPAREN hash_sha2561 RPAREN .

    INPUT           reduce using rule 86 (hash_sha256 -> HASH_SHA256 LPAREN hash_sha2561 RPAREN .)
    PRINT           reduce using rule 86 (hash_sha256 -> HASH_SHA256 LPAREN hash_sha2561 RPAREN .)
    IF              reduce using rule 86 (hash_sha256 -> HASH_SHA256 LPAREN hash_sha2561 RPAREN .)
    FOR             reduce using rule 86 (hash_sha256 -> HASH_SHA256 LPAREN hash_sha2561 RPAREN .)
    WHILE           reduce using rule 86 (hash_sha256 -> HASH_SHA256 LPAREN hash_sha2561 RPAREN .)
    ID              reduce using rule 86 (hash_sha256 -> HASH_SHA256 LPAREN hash_sha2561 RPAREN .)
    GENERATE_KEY    reduce using rule 86 (hash_sha256 -> HASH_SHA256 LPAREN hash_sha2561 RPAREN .)
    OPEN            reduce using rule 86 (hash_sha256 -> HASH_SHA256 LPAREN hash_sha2561 RPAREN .)
    READ            reduce using rule 86 (hash_sha256 -> HASH_SHA256 LPAREN hash_sha2561 RPAREN .)
    WRITE           reduce using rule 86 (hash_sha256 -> HASH_SHA256 LPAREN hash_sha2561 RPAREN .)
    CLOSE           reduce using rule 86 (hash_sha256 -> HASH_SHA256 LPAREN hash_sha2561 RPAREN .)
    ENCRYPT         reduce using rule 86 (hash_sha256 -> HASH_SHA256 LPAREN hash_sha2561 RPAREN .)
    DECRYPT         reduce using rule 86 (hash_sha256 -> HASH_SHA256 LPAREN hash_sha2561 RPAREN .)
    HASH_SHA256     reduce using rule 86 (hash_sha256 -> HASH_SHA256 LPAREN hash_sha2561 RPAREN .)
    HASH_MD5        reduce using rule 86 (hash_sha256 -> HASH_SHA256 LPAREN hash_sha2561 RPAREN .)
    RCURLY          reduce using rule 86 (hash_sha256 -> HASH_SHA256 LPAREN hash_sha2561 RPAREN .)
    RETURN          reduce using rule 86 (hash_sha256 -> HASH_SHA256 LPAREN hash_sha2561 RPAREN .)
    SEMICOL         reduce using rule 86 (hash_sha256 -> HASH_SHA256 LPAREN hash_sha2561 RPAREN .)


state 230

    (89) hash_md5 -> HASH_MD5 LPAREN hash_md51 RPAREN .

    INPUT           reduce using rule 89 (hash_md5 -> HASH_MD5 LPAREN hash_md51 RPAREN .)
    PRINT           reduce using rule 89 (hash_md5 -> HASH_MD5 LPAREN hash_md51 RPAREN .)
    IF              reduce using rule 89 (hash_md5 -> HASH_MD5 LPAREN hash_md51 RPAREN .)
    FOR             reduce using rule 89 (hash_md5 -> HASH_MD5 LPAREN hash_md51 RPAREN .)
    WHILE           reduce using rule 89 (hash_md5 -> HASH_MD5 LPAREN hash_md51 RPAREN .)
    ID              reduce using rule 89 (hash_md5 -> HASH_MD5 LPAREN hash_md51 RPAREN .)
    GENERATE_KEY    reduce using rule 89 (hash_md5 -> HASH_MD5 LPAREN hash_md51 RPAREN .)
    OPEN            reduce using rule 89 (hash_md5 -> HASH_MD5 LPAREN hash_md51 RPAREN .)
    READ            reduce using rule 89 (hash_md5 -> HASH_MD5 LPAREN hash_md51 RPAREN .)
    WRITE           reduce using rule 89 (hash_md5 -> HASH_MD5 LPAREN hash_md51 RPAREN .)
    CLOSE           reduce using rule 89 (hash_md5 -> HASH_MD5 LPAREN hash_md51 RPAREN .)
    ENCRYPT         reduce using rule 89 (hash_md5 -> HASH_MD5 LPAREN hash_md51 RPAREN .)
    DECRYPT         reduce using rule 89 (hash_md5 -> HASH_MD5 LPAREN hash_md51 RPAREN .)
    HASH_SHA256     reduce using rule 89 (hash_md5 -> HASH_MD5 LPAREN hash_md51 RPAREN .)
    HASH_MD5        reduce using rule 89 (hash_md5 -> HASH_MD5 LPAREN hash_md51 RPAREN .)
    RCURLY          reduce using rule 89 (hash_md5 -> HASH_MD5 LPAREN hash_md51 RPAREN .)
    RETURN          reduce using rule 89 (hash_md5 -> HASH_MD5 LPAREN hash_md51 RPAREN .)
    SEMICOL         reduce using rule 89 (hash_md5 -> HASH_MD5 LPAREN hash_md51 RPAREN .)


state 231

    (20) function -> FUNC ID LPAREN param RPAREN ARROW smp_type LCURLY function1 . block RETURN exp SEMICOL RCURLY
    (28) block -> . statement block
    (29) block -> . empty
    (35) statement -> . assignment
    (36) statement -> . c_input
    (37) statement -> . c_print
    (38) statement -> . condition
    (39) statement -> . for_loop
    (40) statement -> . while_loop
    (41) statement -> . std_func
    (42) statement -> . sp_func
    (119) empty -> .
    (43) assignment -> . variable EQUAL assignment1 SEMICOL
    (46) c_input -> . INPUT variable c_input1 SEMICOL
    (49) c_print -> . PRINT LPAREN c_print1 RPAREN SEMICOL
    (54) condition -> . IF LPAREN exp RPAREN LCURLY block RCURLY condition1
    (57) for_loop -> . FOR ID IN RANGE LPAREN exp COMMA exp RPAREN LCURLY block RCURLY
    (58) while_loop -> . WHILE LPAREN exp RPAREN LCURLY block RCURLY
    (59) std_func -> . ID LPAREN std_func1 RPAREN
    (64) sp_func -> . generate_key_func
    (65) sp_func -> . file_func
    (66) sp_func -> . crypto_func
    (30) variable -> . ID variable1
    (75) generate_key_func -> . GENERATE_KEY LPAREN RPAREN
    (67) file_func -> . open_file
    (68) file_func -> . read_file
    (69) file_func -> . write_file
    (70) file_func -> . close_file
    (71) crypto_func -> . encrypt_func
    (72) crypto_func -> . decrypt_func
    (73) crypto_func -> . hash_sha256
    (74) crypto_func -> . hash_md5
    (76) open_file -> . OPEN LPAREN CTE_CHAR RPAREN
    (77) read_file -> . READ LPAREN ID RPAREN
    (78) write_file -> . WRITE LPAREN CTE_CHAR ID RPAREN
    (79) close_file -> . CLOSE LPAREN ID RPAREN
    (80) encrypt_func -> . ENCRYPT LPAREN encrypt_func1 COMMA ID RPAREN
    (83) decrypt_func -> . DECRYPT LPAREN decrypt_func1 COMMA ID RPAREN
    (86) hash_sha256 -> . HASH_SHA256 LPAREN hash_sha2561 RPAREN
    (89) hash_md5 -> . HASH_MD5 LPAREN hash_md51 RPAREN

    RETURN          reduce using rule 119 (empty -> .)
    INPUT           shift and go to state 96
    PRINT           shift and go to state 97
    IF              shift and go to state 98
    FOR             shift and go to state 99
    WHILE           shift and go to state 101
    ID              shift and go to state 100
    GENERATE_KEY    shift and go to state 105
    OPEN            shift and go to state 114
    READ            shift and go to state 115
    WRITE           shift and go to state 116
    CLOSE           shift and go to state 117
    ENCRYPT         shift and go to state 118
    DECRYPT         shift and go to state 119
    HASH_SHA256     shift and go to state 120
    HASH_MD5        shift and go to state 121

    block                          shift and go to state 247
    statement                      shift and go to state 85
    empty                          shift and go to state 86
    assignment                     shift and go to state 87
    c_input                        shift and go to state 88
    c_print                        shift and go to state 89
    condition                      shift and go to state 90
    for_loop                       shift and go to state 91
    while_loop                     shift and go to state 92
    std_func                       shift and go to state 93
    sp_func                        shift and go to state 94
    variable                       shift and go to state 95
    generate_key_func              shift and go to state 102
    file_func                      shift and go to state 103
    crypto_func                    shift and go to state 104
    open_file                      shift and go to state 106
    read_file                      shift and go to state 107
    write_file                     shift and go to state 108
    close_file                     shift and go to state 109
    encrypt_func                   shift and go to state 110
    decrypt_func                   shift and go to state 111
    hash_sha256                    shift and go to state 112
    hash_md5                       shift and go to state 113

state 232

    (22) function1 -> dec_vars .

    INPUT           reduce using rule 22 (function1 -> dec_vars .)
    PRINT           reduce using rule 22 (function1 -> dec_vars .)
    IF              reduce using rule 22 (function1 -> dec_vars .)
    FOR             reduce using rule 22 (function1 -> dec_vars .)
    WHILE           reduce using rule 22 (function1 -> dec_vars .)
    ID              reduce using rule 22 (function1 -> dec_vars .)
    GENERATE_KEY    reduce using rule 22 (function1 -> dec_vars .)
    OPEN            reduce using rule 22 (function1 -> dec_vars .)
    READ            reduce using rule 22 (function1 -> dec_vars .)
    WRITE           reduce using rule 22 (function1 -> dec_vars .)
    CLOSE           reduce using rule 22 (function1 -> dec_vars .)
    ENCRYPT         reduce using rule 22 (function1 -> dec_vars .)
    DECRYPT         reduce using rule 22 (function1 -> dec_vars .)
    HASH_SHA256     reduce using rule 22 (function1 -> dec_vars .)
    HASH_MD5        reduce using rule 22 (function1 -> dec_vars .)
    RETURN          reduce using rule 22 (function1 -> dec_vars .)
    RCURLY          reduce using rule 22 (function1 -> dec_vars .)


state 233

    (23) function1 -> empty .

    INPUT           reduce using rule 23 (function1 -> empty .)
    PRINT           reduce using rule 23 (function1 -> empty .)
    IF              reduce using rule 23 (function1 -> empty .)
    FOR             reduce using rule 23 (function1 -> empty .)
    WHILE           reduce using rule 23 (function1 -> empty .)
    ID              reduce using rule 23 (function1 -> empty .)
    GENERATE_KEY    reduce using rule 23 (function1 -> empty .)
    OPEN            reduce using rule 23 (function1 -> empty .)
    READ            reduce using rule 23 (function1 -> empty .)
    WRITE           reduce using rule 23 (function1 -> empty .)
    CLOSE           reduce using rule 23 (function1 -> empty .)
    ENCRYPT         reduce using rule 23 (function1 -> empty .)
    DECRYPT         reduce using rule 23 (function1 -> empty .)
    HASH_SHA256     reduce using rule 23 (function1 -> empty .)
    HASH_MD5        reduce using rule 23 (function1 -> empty .)
    RETURN          reduce using rule 23 (function1 -> empty .)
    RCURLY          reduce using rule 23 (function1 -> empty .)


state 234

    (21) function -> FUNC ID LPAREN param RPAREN ARROW VOID LCURLY function1 . block RCURLY
    (28) block -> . statement block
    (29) block -> . empty
    (35) statement -> . assignment
    (36) statement -> . c_input
    (37) statement -> . c_print
    (38) statement -> . condition
    (39) statement -> . for_loop
    (40) statement -> . while_loop
    (41) statement -> . std_func
    (42) statement -> . sp_func
    (119) empty -> .
    (43) assignment -> . variable EQUAL assignment1 SEMICOL
    (46) c_input -> . INPUT variable c_input1 SEMICOL
    (49) c_print -> . PRINT LPAREN c_print1 RPAREN SEMICOL
    (54) condition -> . IF LPAREN exp RPAREN LCURLY block RCURLY condition1
    (57) for_loop -> . FOR ID IN RANGE LPAREN exp COMMA exp RPAREN LCURLY block RCURLY
    (58) while_loop -> . WHILE LPAREN exp RPAREN LCURLY block RCURLY
    (59) std_func -> . ID LPAREN std_func1 RPAREN
    (64) sp_func -> . generate_key_func
    (65) sp_func -> . file_func
    (66) sp_func -> . crypto_func
    (30) variable -> . ID variable1
    (75) generate_key_func -> . GENERATE_KEY LPAREN RPAREN
    (67) file_func -> . open_file
    (68) file_func -> . read_file
    (69) file_func -> . write_file
    (70) file_func -> . close_file
    (71) crypto_func -> . encrypt_func
    (72) crypto_func -> . decrypt_func
    (73) crypto_func -> . hash_sha256
    (74) crypto_func -> . hash_md5
    (76) open_file -> . OPEN LPAREN CTE_CHAR RPAREN
    (77) read_file -> . READ LPAREN ID RPAREN
    (78) write_file -> . WRITE LPAREN CTE_CHAR ID RPAREN
    (79) close_file -> . CLOSE LPAREN ID RPAREN
    (80) encrypt_func -> . ENCRYPT LPAREN encrypt_func1 COMMA ID RPAREN
    (83) decrypt_func -> . DECRYPT LPAREN decrypt_func1 COMMA ID RPAREN
    (86) hash_sha256 -> . HASH_SHA256 LPAREN hash_sha2561 RPAREN
    (89) hash_md5 -> . HASH_MD5 LPAREN hash_md51 RPAREN

    RCURLY          reduce using rule 119 (empty -> .)
    INPUT           shift and go to state 96
    PRINT           shift and go to state 97
    IF              shift and go to state 98
    FOR             shift and go to state 99
    WHILE           shift and go to state 101
    ID              shift and go to state 100
    GENERATE_KEY    shift and go to state 105
    OPEN            shift and go to state 114
    READ            shift and go to state 115
    WRITE           shift and go to state 116
    CLOSE           shift and go to state 117
    ENCRYPT         shift and go to state 118
    DECRYPT         shift and go to state 119
    HASH_SHA256     shift and go to state 120
    HASH_MD5        shift and go to state 121

    block                          shift and go to state 248
    statement                      shift and go to state 85
    empty                          shift and go to state 86
    assignment                     shift and go to state 87
    c_input                        shift and go to state 88
    c_print                        shift and go to state 89
    condition                      shift and go to state 90
    for_loop                       shift and go to state 91
    while_loop                     shift and go to state 92
    std_func                       shift and go to state 93
    sp_func                        shift and go to state 94
    variable                       shift and go to state 95
    generate_key_func              shift and go to state 102
    file_func                      shift and go to state 103
    crypto_func                    shift and go to state 104
    open_file                      shift and go to state 106
    read_file                      shift and go to state 107
    write_file                     shift and go to state 108
    close_file                     shift and go to state 109
    encrypt_func                   shift and go to state 110
    decrypt_func                   shift and go to state 111
    hash_sha256                    shift and go to state 112
    hash_md5                       shift and go to state 113

state 235

    (26) param1 -> COMMA smp_type ID param1 .

    RPAREN          reduce using rule 26 (param1 -> COMMA smp_type ID param1 .)


state 236

    (62) std_func2 -> COMMA exp std_func2 .

    RPAREN          reduce using rule 62 (std_func2 -> COMMA exp std_func2 .)


state 237

    (33) variable2 -> LBRACKET exp . RBRACKET

    RBRACKET        shift and go to state 249


state 238

    (47) c_input1 -> COMMA variable c_input1 .

    SEMICOL         reduce using rule 47 (c_input1 -> COMMA variable c_input1 .)


state 239

    (49) c_print -> PRINT LPAREN c_print1 RPAREN SEMICOL .

    INPUT           reduce using rule 49 (c_print -> PRINT LPAREN c_print1 RPAREN SEMICOL .)
    PRINT           reduce using rule 49 (c_print -> PRINT LPAREN c_print1 RPAREN SEMICOL .)
    IF              reduce using rule 49 (c_print -> PRINT LPAREN c_print1 RPAREN SEMICOL .)
    FOR             reduce using rule 49 (c_print -> PRINT LPAREN c_print1 RPAREN SEMICOL .)
    WHILE           reduce using rule 49 (c_print -> PRINT LPAREN c_print1 RPAREN SEMICOL .)
    ID              reduce using rule 49 (c_print -> PRINT LPAREN c_print1 RPAREN SEMICOL .)
    GENERATE_KEY    reduce using rule 49 (c_print -> PRINT LPAREN c_print1 RPAREN SEMICOL .)
    OPEN            reduce using rule 49 (c_print -> PRINT LPAREN c_print1 RPAREN SEMICOL .)
    READ            reduce using rule 49 (c_print -> PRINT LPAREN c_print1 RPAREN SEMICOL .)
    WRITE           reduce using rule 49 (c_print -> PRINT LPAREN c_print1 RPAREN SEMICOL .)
    CLOSE           reduce using rule 49 (c_print -> PRINT LPAREN c_print1 RPAREN SEMICOL .)
    ENCRYPT         reduce using rule 49 (c_print -> PRINT LPAREN c_print1 RPAREN SEMICOL .)
    DECRYPT         reduce using rule 49 (c_print -> PRINT LPAREN c_print1 RPAREN SEMICOL .)
    HASH_SHA256     reduce using rule 49 (c_print -> PRINT LPAREN c_print1 RPAREN SEMICOL .)
    HASH_MD5        reduce using rule 49 (c_print -> PRINT LPAREN c_print1 RPAREN SEMICOL .)
    RCURLY          reduce using rule 49 (c_print -> PRINT LPAREN c_print1 RPAREN SEMICOL .)
    RETURN          reduce using rule 49 (c_print -> PRINT LPAREN c_print1 RPAREN SEMICOL .)


state 240

    (52) c_print2 -> COMMA c_print1 .

    RPAREN          reduce using rule 52 (c_print2 -> COMMA c_print1 .)


state 241

    (54) condition -> IF LPAREN exp RPAREN LCURLY . block RCURLY condition1
    (28) block -> . statement block
    (29) block -> . empty
    (35) statement -> . assignment
    (36) statement -> . c_input
    (37) statement -> . c_print
    (38) statement -> . condition
    (39) statement -> . for_loop
    (40) statement -> . while_loop
    (41) statement -> . std_func
    (42) statement -> . sp_func
    (119) empty -> .
    (43) assignment -> . variable EQUAL assignment1 SEMICOL
    (46) c_input -> . INPUT variable c_input1 SEMICOL
    (49) c_print -> . PRINT LPAREN c_print1 RPAREN SEMICOL
    (54) condition -> . IF LPAREN exp RPAREN LCURLY block RCURLY condition1
    (57) for_loop -> . FOR ID IN RANGE LPAREN exp COMMA exp RPAREN LCURLY block RCURLY
    (58) while_loop -> . WHILE LPAREN exp RPAREN LCURLY block RCURLY
    (59) std_func -> . ID LPAREN std_func1 RPAREN
    (64) sp_func -> . generate_key_func
    (65) sp_func -> . file_func
    (66) sp_func -> . crypto_func
    (30) variable -> . ID variable1
    (75) generate_key_func -> . GENERATE_KEY LPAREN RPAREN
    (67) file_func -> . open_file
    (68) file_func -> . read_file
    (69) file_func -> . write_file
    (70) file_func -> . close_file
    (71) crypto_func -> . encrypt_func
    (72) crypto_func -> . decrypt_func
    (73) crypto_func -> . hash_sha256
    (74) crypto_func -> . hash_md5
    (76) open_file -> . OPEN LPAREN CTE_CHAR RPAREN
    (77) read_file -> . READ LPAREN ID RPAREN
    (78) write_file -> . WRITE LPAREN CTE_CHAR ID RPAREN
    (79) close_file -> . CLOSE LPAREN ID RPAREN
    (80) encrypt_func -> . ENCRYPT LPAREN encrypt_func1 COMMA ID RPAREN
    (83) decrypt_func -> . DECRYPT LPAREN decrypt_func1 COMMA ID RPAREN
    (86) hash_sha256 -> . HASH_SHA256 LPAREN hash_sha2561 RPAREN
    (89) hash_md5 -> . HASH_MD5 LPAREN hash_md51 RPAREN

    RCURLY          reduce using rule 119 (empty -> .)
    INPUT           shift and go to state 96
    PRINT           shift and go to state 97
    IF              shift and go to state 98
    FOR             shift and go to state 99
    WHILE           shift and go to state 101
    ID              shift and go to state 100
    GENERATE_KEY    shift and go to state 105
    OPEN            shift and go to state 114
    READ            shift and go to state 115
    WRITE           shift and go to state 116
    CLOSE           shift and go to state 117
    ENCRYPT         shift and go to state 118
    DECRYPT         shift and go to state 119
    HASH_SHA256     shift and go to state 120
    HASH_MD5        shift and go to state 121

    block                          shift and go to state 250
    statement                      shift and go to state 85
    empty                          shift and go to state 86
    assignment                     shift and go to state 87
    c_input                        shift and go to state 88
    c_print                        shift and go to state 89
    condition                      shift and go to state 90
    for_loop                       shift and go to state 91
    while_loop                     shift and go to state 92
    std_func                       shift and go to state 93
    sp_func                        shift and go to state 94
    variable                       shift and go to state 95
    generate_key_func              shift and go to state 102
    file_func                      shift and go to state 103
    crypto_func                    shift and go to state 104
    open_file                      shift and go to state 106
    read_file                      shift and go to state 107
    write_file                     shift and go to state 108
    close_file                     shift and go to state 109
    encrypt_func                   shift and go to state 110
    decrypt_func                   shift and go to state 111
    hash_sha256                    shift and go to state 112
    hash_md5                       shift and go to state 113

state 242

    (57) for_loop -> FOR ID IN RANGE LPAREN . exp COMMA exp RPAREN LCURLY block RCURLY
    (92) exp -> . t_exp exp1
    (95) t_exp -> . g_exp t_exp1
    (98) g_exp -> . m_exp g_exp1
    (106) m_exp -> . term m_exp1
    (110) term -> . factor term1
    (114) factor -> . LPAREN exp RPAREN
    (115) factor -> . variable
    (116) factor -> . std_func
    (117) factor -> . CTE_INT
    (118) factor -> . CTE_FLOAT
    (30) variable -> . ID variable1
    (59) std_func -> . ID LPAREN std_func1 RPAREN

    LPAREN          shift and go to state 40
    CTE_INT         shift and go to state 43
    CTE_FLOAT       shift and go to state 44
    ID              shift and go to state 33

    exp                            shift and go to state 251
    t_exp                          shift and go to state 35
    g_exp                          shift and go to state 36
    m_exp                          shift and go to state 37
    term                           shift and go to state 38
    factor                         shift and go to state 39
    variable                       shift and go to state 41
    std_func                       shift and go to state 42

state 243

    (58) while_loop -> WHILE LPAREN exp RPAREN LCURLY . block RCURLY
    (28) block -> . statement block
    (29) block -> . empty
    (35) statement -> . assignment
    (36) statement -> . c_input
    (37) statement -> . c_print
    (38) statement -> . condition
    (39) statement -> . for_loop
    (40) statement -> . while_loop
    (41) statement -> . std_func
    (42) statement -> . sp_func
    (119) empty -> .
    (43) assignment -> . variable EQUAL assignment1 SEMICOL
    (46) c_input -> . INPUT variable c_input1 SEMICOL
    (49) c_print -> . PRINT LPAREN c_print1 RPAREN SEMICOL
    (54) condition -> . IF LPAREN exp RPAREN LCURLY block RCURLY condition1
    (57) for_loop -> . FOR ID IN RANGE LPAREN exp COMMA exp RPAREN LCURLY block RCURLY
    (58) while_loop -> . WHILE LPAREN exp RPAREN LCURLY block RCURLY
    (59) std_func -> . ID LPAREN std_func1 RPAREN
    (64) sp_func -> . generate_key_func
    (65) sp_func -> . file_func
    (66) sp_func -> . crypto_func
    (30) variable -> . ID variable1
    (75) generate_key_func -> . GENERATE_KEY LPAREN RPAREN
    (67) file_func -> . open_file
    (68) file_func -> . read_file
    (69) file_func -> . write_file
    (70) file_func -> . close_file
    (71) crypto_func -> . encrypt_func
    (72) crypto_func -> . decrypt_func
    (73) crypto_func -> . hash_sha256
    (74) crypto_func -> . hash_md5
    (76) open_file -> . OPEN LPAREN CTE_CHAR RPAREN
    (77) read_file -> . READ LPAREN ID RPAREN
    (78) write_file -> . WRITE LPAREN CTE_CHAR ID RPAREN
    (79) close_file -> . CLOSE LPAREN ID RPAREN
    (80) encrypt_func -> . ENCRYPT LPAREN encrypt_func1 COMMA ID RPAREN
    (83) decrypt_func -> . DECRYPT LPAREN decrypt_func1 COMMA ID RPAREN
    (86) hash_sha256 -> . HASH_SHA256 LPAREN hash_sha2561 RPAREN
    (89) hash_md5 -> . HASH_MD5 LPAREN hash_md51 RPAREN

    RCURLY          reduce using rule 119 (empty -> .)
    INPUT           shift and go to state 96
    PRINT           shift and go to state 97
    IF              shift and go to state 98
    FOR             shift and go to state 99
    WHILE           shift and go to state 101
    ID              shift and go to state 100
    GENERATE_KEY    shift and go to state 105
    OPEN            shift and go to state 114
    READ            shift and go to state 115
    WRITE           shift and go to state 116
    CLOSE           shift and go to state 117
    ENCRYPT         shift and go to state 118
    DECRYPT         shift and go to state 119
    HASH_SHA256     shift and go to state 120
    HASH_MD5        shift and go to state 121

    block                          shift and go to state 252
    statement                      shift and go to state 85
    empty                          shift and go to state 86
    assignment                     shift and go to state 87
    c_input                        shift and go to state 88
    c_print                        shift and go to state 89
    condition                      shift and go to state 90
    for_loop                       shift and go to state 91
    while_loop                     shift and go to state 92
    std_func                       shift and go to state 93
    sp_func                        shift and go to state 94
    variable                       shift and go to state 95
    generate_key_func              shift and go to state 102
    file_func                      shift and go to state 103
    crypto_func                    shift and go to state 104
    open_file                      shift and go to state 106
    read_file                      shift and go to state 107
    write_file                     shift and go to state 108
    close_file                     shift and go to state 109
    encrypt_func                   shift and go to state 110
    decrypt_func                   shift and go to state 111
    hash_sha256                    shift and go to state 112
    hash_md5                       shift and go to state 113

state 244

    (78) write_file -> WRITE LPAREN CTE_CHAR ID RPAREN .

    INPUT           reduce using rule 78 (write_file -> WRITE LPAREN CTE_CHAR ID RPAREN .)
    PRINT           reduce using rule 78 (write_file -> WRITE LPAREN CTE_CHAR ID RPAREN .)
    IF              reduce using rule 78 (write_file -> WRITE LPAREN CTE_CHAR ID RPAREN .)
    FOR             reduce using rule 78 (write_file -> WRITE LPAREN CTE_CHAR ID RPAREN .)
    WHILE           reduce using rule 78 (write_file -> WRITE LPAREN CTE_CHAR ID RPAREN .)
    ID              reduce using rule 78 (write_file -> WRITE LPAREN CTE_CHAR ID RPAREN .)
    GENERATE_KEY    reduce using rule 78 (write_file -> WRITE LPAREN CTE_CHAR ID RPAREN .)
    OPEN            reduce using rule 78 (write_file -> WRITE LPAREN CTE_CHAR ID RPAREN .)
    READ            reduce using rule 78 (write_file -> WRITE LPAREN CTE_CHAR ID RPAREN .)
    WRITE           reduce using rule 78 (write_file -> WRITE LPAREN CTE_CHAR ID RPAREN .)
    CLOSE           reduce using rule 78 (write_file -> WRITE LPAREN CTE_CHAR ID RPAREN .)
    ENCRYPT         reduce using rule 78 (write_file -> WRITE LPAREN CTE_CHAR ID RPAREN .)
    DECRYPT         reduce using rule 78 (write_file -> WRITE LPAREN CTE_CHAR ID RPAREN .)
    HASH_SHA256     reduce using rule 78 (write_file -> WRITE LPAREN CTE_CHAR ID RPAREN .)
    HASH_MD5        reduce using rule 78 (write_file -> WRITE LPAREN CTE_CHAR ID RPAREN .)
    RCURLY          reduce using rule 78 (write_file -> WRITE LPAREN CTE_CHAR ID RPAREN .)
    RETURN          reduce using rule 78 (write_file -> WRITE LPAREN CTE_CHAR ID RPAREN .)
    SEMICOL         reduce using rule 78 (write_file -> WRITE LPAREN CTE_CHAR ID RPAREN .)


state 245

    (80) encrypt_func -> ENCRYPT LPAREN encrypt_func1 COMMA ID . RPAREN

    RPAREN          shift and go to state 253


state 246

    (83) decrypt_func -> DECRYPT LPAREN decrypt_func1 COMMA ID . RPAREN

    RPAREN          shift and go to state 254


state 247

    (20) function -> FUNC ID LPAREN param RPAREN ARROW smp_type LCURLY function1 block . RETURN exp SEMICOL RCURLY

    RETURN          shift and go to state 255


state 248

    (21) function -> FUNC ID LPAREN param RPAREN ARROW VOID LCURLY function1 block . RCURLY

    RCURLY          shift and go to state 256


state 249

    (33) variable2 -> LBRACKET exp RBRACKET .

    TIMES           reduce using rule 33 (variable2 -> LBRACKET exp RBRACKET .)
    DIVIDE          reduce using rule 33 (variable2 -> LBRACKET exp RBRACKET .)
    PLUS            reduce using rule 33 (variable2 -> LBRACKET exp RBRACKET .)
    MINUS           reduce using rule 33 (variable2 -> LBRACKET exp RBRACKET .)
    GT              reduce using rule 33 (variable2 -> LBRACKET exp RBRACKET .)
    LT              reduce using rule 33 (variable2 -> LBRACKET exp RBRACKET .)
    GE              reduce using rule 33 (variable2 -> LBRACKET exp RBRACKET .)
    LE              reduce using rule 33 (variable2 -> LBRACKET exp RBRACKET .)
    EQ              reduce using rule 33 (variable2 -> LBRACKET exp RBRACKET .)
    NE              reduce using rule 33 (variable2 -> LBRACKET exp RBRACKET .)
    AND             reduce using rule 33 (variable2 -> LBRACKET exp RBRACKET .)
    OR              reduce using rule 33 (variable2 -> LBRACKET exp RBRACKET .)
    RBRACKET        reduce using rule 33 (variable2 -> LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 33 (variable2 -> LBRACKET exp RBRACKET .)
    COMMA           reduce using rule 33 (variable2 -> LBRACKET exp RBRACKET .)
    SEMICOL         reduce using rule 33 (variable2 -> LBRACKET exp RBRACKET .)
    EQUAL           reduce using rule 33 (variable2 -> LBRACKET exp RBRACKET .)


state 250

    (54) condition -> IF LPAREN exp RPAREN LCURLY block . RCURLY condition1

    RCURLY          shift and go to state 257


state 251

    (57) for_loop -> FOR ID IN RANGE LPAREN exp . COMMA exp RPAREN LCURLY block RCURLY

    COMMA           shift and go to state 258


state 252

    (58) while_loop -> WHILE LPAREN exp RPAREN LCURLY block . RCURLY

    RCURLY          shift and go to state 259


state 253

    (80) encrypt_func -> ENCRYPT LPAREN encrypt_func1 COMMA ID RPAREN .

    INPUT           reduce using rule 80 (encrypt_func -> ENCRYPT LPAREN encrypt_func1 COMMA ID RPAREN .)
    PRINT           reduce using rule 80 (encrypt_func -> ENCRYPT LPAREN encrypt_func1 COMMA ID RPAREN .)
    IF              reduce using rule 80 (encrypt_func -> ENCRYPT LPAREN encrypt_func1 COMMA ID RPAREN .)
    FOR             reduce using rule 80 (encrypt_func -> ENCRYPT LPAREN encrypt_func1 COMMA ID RPAREN .)
    WHILE           reduce using rule 80 (encrypt_func -> ENCRYPT LPAREN encrypt_func1 COMMA ID RPAREN .)
    ID              reduce using rule 80 (encrypt_func -> ENCRYPT LPAREN encrypt_func1 COMMA ID RPAREN .)
    GENERATE_KEY    reduce using rule 80 (encrypt_func -> ENCRYPT LPAREN encrypt_func1 COMMA ID RPAREN .)
    OPEN            reduce using rule 80 (encrypt_func -> ENCRYPT LPAREN encrypt_func1 COMMA ID RPAREN .)
    READ            reduce using rule 80 (encrypt_func -> ENCRYPT LPAREN encrypt_func1 COMMA ID RPAREN .)
    WRITE           reduce using rule 80 (encrypt_func -> ENCRYPT LPAREN encrypt_func1 COMMA ID RPAREN .)
    CLOSE           reduce using rule 80 (encrypt_func -> ENCRYPT LPAREN encrypt_func1 COMMA ID RPAREN .)
    ENCRYPT         reduce using rule 80 (encrypt_func -> ENCRYPT LPAREN encrypt_func1 COMMA ID RPAREN .)
    DECRYPT         reduce using rule 80 (encrypt_func -> ENCRYPT LPAREN encrypt_func1 COMMA ID RPAREN .)
    HASH_SHA256     reduce using rule 80 (encrypt_func -> ENCRYPT LPAREN encrypt_func1 COMMA ID RPAREN .)
    HASH_MD5        reduce using rule 80 (encrypt_func -> ENCRYPT LPAREN encrypt_func1 COMMA ID RPAREN .)
    RCURLY          reduce using rule 80 (encrypt_func -> ENCRYPT LPAREN encrypt_func1 COMMA ID RPAREN .)
    RETURN          reduce using rule 80 (encrypt_func -> ENCRYPT LPAREN encrypt_func1 COMMA ID RPAREN .)
    SEMICOL         reduce using rule 80 (encrypt_func -> ENCRYPT LPAREN encrypt_func1 COMMA ID RPAREN .)


state 254

    (83) decrypt_func -> DECRYPT LPAREN decrypt_func1 COMMA ID RPAREN .

    INPUT           reduce using rule 83 (decrypt_func -> DECRYPT LPAREN decrypt_func1 COMMA ID RPAREN .)
    PRINT           reduce using rule 83 (decrypt_func -> DECRYPT LPAREN decrypt_func1 COMMA ID RPAREN .)
    IF              reduce using rule 83 (decrypt_func -> DECRYPT LPAREN decrypt_func1 COMMA ID RPAREN .)
    FOR             reduce using rule 83 (decrypt_func -> DECRYPT LPAREN decrypt_func1 COMMA ID RPAREN .)
    WHILE           reduce using rule 83 (decrypt_func -> DECRYPT LPAREN decrypt_func1 COMMA ID RPAREN .)
    ID              reduce using rule 83 (decrypt_func -> DECRYPT LPAREN decrypt_func1 COMMA ID RPAREN .)
    GENERATE_KEY    reduce using rule 83 (decrypt_func -> DECRYPT LPAREN decrypt_func1 COMMA ID RPAREN .)
    OPEN            reduce using rule 83 (decrypt_func -> DECRYPT LPAREN decrypt_func1 COMMA ID RPAREN .)
    READ            reduce using rule 83 (decrypt_func -> DECRYPT LPAREN decrypt_func1 COMMA ID RPAREN .)
    WRITE           reduce using rule 83 (decrypt_func -> DECRYPT LPAREN decrypt_func1 COMMA ID RPAREN .)
    CLOSE           reduce using rule 83 (decrypt_func -> DECRYPT LPAREN decrypt_func1 COMMA ID RPAREN .)
    ENCRYPT         reduce using rule 83 (decrypt_func -> DECRYPT LPAREN decrypt_func1 COMMA ID RPAREN .)
    DECRYPT         reduce using rule 83 (decrypt_func -> DECRYPT LPAREN decrypt_func1 COMMA ID RPAREN .)
    HASH_SHA256     reduce using rule 83 (decrypt_func -> DECRYPT LPAREN decrypt_func1 COMMA ID RPAREN .)
    HASH_MD5        reduce using rule 83 (decrypt_func -> DECRYPT LPAREN decrypt_func1 COMMA ID RPAREN .)
    RCURLY          reduce using rule 83 (decrypt_func -> DECRYPT LPAREN decrypt_func1 COMMA ID RPAREN .)
    RETURN          reduce using rule 83 (decrypt_func -> DECRYPT LPAREN decrypt_func1 COMMA ID RPAREN .)
    SEMICOL         reduce using rule 83 (decrypt_func -> DECRYPT LPAREN decrypt_func1 COMMA ID RPAREN .)


state 255

    (20) function -> FUNC ID LPAREN param RPAREN ARROW smp_type LCURLY function1 block RETURN . exp SEMICOL RCURLY
    (92) exp -> . t_exp exp1
    (95) t_exp -> . g_exp t_exp1
    (98) g_exp -> . m_exp g_exp1
    (106) m_exp -> . term m_exp1
    (110) term -> . factor term1
    (114) factor -> . LPAREN exp RPAREN
    (115) factor -> . variable
    (116) factor -> . std_func
    (117) factor -> . CTE_INT
    (118) factor -> . CTE_FLOAT
    (30) variable -> . ID variable1
    (59) std_func -> . ID LPAREN std_func1 RPAREN

    LPAREN          shift and go to state 40
    CTE_INT         shift and go to state 43
    CTE_FLOAT       shift and go to state 44
    ID              shift and go to state 33

    exp                            shift and go to state 260
    t_exp                          shift and go to state 35
    g_exp                          shift and go to state 36
    m_exp                          shift and go to state 37
    term                           shift and go to state 38
    factor                         shift and go to state 39
    variable                       shift and go to state 41
    std_func                       shift and go to state 42

state 256

    (21) function -> FUNC ID LPAREN param RPAREN ARROW VOID LCURLY function1 block RCURLY .

    FUNC            reduce using rule 21 (function -> FUNC ID LPAREN param RPAREN ARROW VOID LCURLY function1 block RCURLY .)
    MAIN            reduce using rule 21 (function -> FUNC ID LPAREN param RPAREN ARROW VOID LCURLY function1 block RCURLY .)


state 257

    (54) condition -> IF LPAREN exp RPAREN LCURLY block RCURLY . condition1
    (55) condition1 -> . ELSE LCURLY block RCURLY
    (56) condition1 -> . empty
    (119) empty -> .

    ELSE            shift and go to state 262
    INPUT           reduce using rule 119 (empty -> .)
    PRINT           reduce using rule 119 (empty -> .)
    IF              reduce using rule 119 (empty -> .)
    FOR             reduce using rule 119 (empty -> .)
    WHILE           reduce using rule 119 (empty -> .)
    ID              reduce using rule 119 (empty -> .)
    GENERATE_KEY    reduce using rule 119 (empty -> .)
    OPEN            reduce using rule 119 (empty -> .)
    READ            reduce using rule 119 (empty -> .)
    WRITE           reduce using rule 119 (empty -> .)
    CLOSE           reduce using rule 119 (empty -> .)
    ENCRYPT         reduce using rule 119 (empty -> .)
    DECRYPT         reduce using rule 119 (empty -> .)
    HASH_SHA256     reduce using rule 119 (empty -> .)
    HASH_MD5        reduce using rule 119 (empty -> .)
    RCURLY          reduce using rule 119 (empty -> .)
    RETURN          reduce using rule 119 (empty -> .)

    condition1                     shift and go to state 261
    empty                          shift and go to state 263

state 258

    (57) for_loop -> FOR ID IN RANGE LPAREN exp COMMA . exp RPAREN LCURLY block RCURLY
    (92) exp -> . t_exp exp1
    (95) t_exp -> . g_exp t_exp1
    (98) g_exp -> . m_exp g_exp1
    (106) m_exp -> . term m_exp1
    (110) term -> . factor term1
    (114) factor -> . LPAREN exp RPAREN
    (115) factor -> . variable
    (116) factor -> . std_func
    (117) factor -> . CTE_INT
    (118) factor -> . CTE_FLOAT
    (30) variable -> . ID variable1
    (59) std_func -> . ID LPAREN std_func1 RPAREN

    LPAREN          shift and go to state 40
    CTE_INT         shift and go to state 43
    CTE_FLOAT       shift and go to state 44
    ID              shift and go to state 33

    exp                            shift and go to state 264
    t_exp                          shift and go to state 35
    g_exp                          shift and go to state 36
    m_exp                          shift and go to state 37
    term                           shift and go to state 38
    factor                         shift and go to state 39
    variable                       shift and go to state 41
    std_func                       shift and go to state 42

state 259

    (58) while_loop -> WHILE LPAREN exp RPAREN LCURLY block RCURLY .

    INPUT           reduce using rule 58 (while_loop -> WHILE LPAREN exp RPAREN LCURLY block RCURLY .)
    PRINT           reduce using rule 58 (while_loop -> WHILE LPAREN exp RPAREN LCURLY block RCURLY .)
    IF              reduce using rule 58 (while_loop -> WHILE LPAREN exp RPAREN LCURLY block RCURLY .)
    FOR             reduce using rule 58 (while_loop -> WHILE LPAREN exp RPAREN LCURLY block RCURLY .)
    WHILE           reduce using rule 58 (while_loop -> WHILE LPAREN exp RPAREN LCURLY block RCURLY .)
    ID              reduce using rule 58 (while_loop -> WHILE LPAREN exp RPAREN LCURLY block RCURLY .)
    GENERATE_KEY    reduce using rule 58 (while_loop -> WHILE LPAREN exp RPAREN LCURLY block RCURLY .)
    OPEN            reduce using rule 58 (while_loop -> WHILE LPAREN exp RPAREN LCURLY block RCURLY .)
    READ            reduce using rule 58 (while_loop -> WHILE LPAREN exp RPAREN LCURLY block RCURLY .)
    WRITE           reduce using rule 58 (while_loop -> WHILE LPAREN exp RPAREN LCURLY block RCURLY .)
    CLOSE           reduce using rule 58 (while_loop -> WHILE LPAREN exp RPAREN LCURLY block RCURLY .)
    ENCRYPT         reduce using rule 58 (while_loop -> WHILE LPAREN exp RPAREN LCURLY block RCURLY .)
    DECRYPT         reduce using rule 58 (while_loop -> WHILE LPAREN exp RPAREN LCURLY block RCURLY .)
    HASH_SHA256     reduce using rule 58 (while_loop -> WHILE LPAREN exp RPAREN LCURLY block RCURLY .)
    HASH_MD5        reduce using rule 58 (while_loop -> WHILE LPAREN exp RPAREN LCURLY block RCURLY .)
    RCURLY          reduce using rule 58 (while_loop -> WHILE LPAREN exp RPAREN LCURLY block RCURLY .)
    RETURN          reduce using rule 58 (while_loop -> WHILE LPAREN exp RPAREN LCURLY block RCURLY .)


state 260

    (20) function -> FUNC ID LPAREN param RPAREN ARROW smp_type LCURLY function1 block RETURN exp . SEMICOL RCURLY

    SEMICOL         shift and go to state 265


state 261

    (54) condition -> IF LPAREN exp RPAREN LCURLY block RCURLY condition1 .

    INPUT           reduce using rule 54 (condition -> IF LPAREN exp RPAREN LCURLY block RCURLY condition1 .)
    PRINT           reduce using rule 54 (condition -> IF LPAREN exp RPAREN LCURLY block RCURLY condition1 .)
    IF              reduce using rule 54 (condition -> IF LPAREN exp RPAREN LCURLY block RCURLY condition1 .)
    FOR             reduce using rule 54 (condition -> IF LPAREN exp RPAREN LCURLY block RCURLY condition1 .)
    WHILE           reduce using rule 54 (condition -> IF LPAREN exp RPAREN LCURLY block RCURLY condition1 .)
    ID              reduce using rule 54 (condition -> IF LPAREN exp RPAREN LCURLY block RCURLY condition1 .)
    GENERATE_KEY    reduce using rule 54 (condition -> IF LPAREN exp RPAREN LCURLY block RCURLY condition1 .)
    OPEN            reduce using rule 54 (condition -> IF LPAREN exp RPAREN LCURLY block RCURLY condition1 .)
    READ            reduce using rule 54 (condition -> IF LPAREN exp RPAREN LCURLY block RCURLY condition1 .)
    WRITE           reduce using rule 54 (condition -> IF LPAREN exp RPAREN LCURLY block RCURLY condition1 .)
    CLOSE           reduce using rule 54 (condition -> IF LPAREN exp RPAREN LCURLY block RCURLY condition1 .)
    ENCRYPT         reduce using rule 54 (condition -> IF LPAREN exp RPAREN LCURLY block RCURLY condition1 .)
    DECRYPT         reduce using rule 54 (condition -> IF LPAREN exp RPAREN LCURLY block RCURLY condition1 .)
    HASH_SHA256     reduce using rule 54 (condition -> IF LPAREN exp RPAREN LCURLY block RCURLY condition1 .)
    HASH_MD5        reduce using rule 54 (condition -> IF LPAREN exp RPAREN LCURLY block RCURLY condition1 .)
    RCURLY          reduce using rule 54 (condition -> IF LPAREN exp RPAREN LCURLY block RCURLY condition1 .)
    RETURN          reduce using rule 54 (condition -> IF LPAREN exp RPAREN LCURLY block RCURLY condition1 .)


state 262

    (55) condition1 -> ELSE . LCURLY block RCURLY

    LCURLY          shift and go to state 266


state 263

    (56) condition1 -> empty .

    INPUT           reduce using rule 56 (condition1 -> empty .)
    PRINT           reduce using rule 56 (condition1 -> empty .)
    IF              reduce using rule 56 (condition1 -> empty .)
    FOR             reduce using rule 56 (condition1 -> empty .)
    WHILE           reduce using rule 56 (condition1 -> empty .)
    ID              reduce using rule 56 (condition1 -> empty .)
    GENERATE_KEY    reduce using rule 56 (condition1 -> empty .)
    OPEN            reduce using rule 56 (condition1 -> empty .)
    READ            reduce using rule 56 (condition1 -> empty .)
    WRITE           reduce using rule 56 (condition1 -> empty .)
    CLOSE           reduce using rule 56 (condition1 -> empty .)
    ENCRYPT         reduce using rule 56 (condition1 -> empty .)
    DECRYPT         reduce using rule 56 (condition1 -> empty .)
    HASH_SHA256     reduce using rule 56 (condition1 -> empty .)
    HASH_MD5        reduce using rule 56 (condition1 -> empty .)
    RCURLY          reduce using rule 56 (condition1 -> empty .)
    RETURN          reduce using rule 56 (condition1 -> empty .)


state 264

    (57) for_loop -> FOR ID IN RANGE LPAREN exp COMMA exp . RPAREN LCURLY block RCURLY

    RPAREN          shift and go to state 267


state 265

    (20) function -> FUNC ID LPAREN param RPAREN ARROW smp_type LCURLY function1 block RETURN exp SEMICOL . RCURLY

    RCURLY          shift and go to state 268


state 266

    (55) condition1 -> ELSE LCURLY . block RCURLY
    (28) block -> . statement block
    (29) block -> . empty
    (35) statement -> . assignment
    (36) statement -> . c_input
    (37) statement -> . c_print
    (38) statement -> . condition
    (39) statement -> . for_loop
    (40) statement -> . while_loop
    (41) statement -> . std_func
    (42) statement -> . sp_func
    (119) empty -> .
    (43) assignment -> . variable EQUAL assignment1 SEMICOL
    (46) c_input -> . INPUT variable c_input1 SEMICOL
    (49) c_print -> . PRINT LPAREN c_print1 RPAREN SEMICOL
    (54) condition -> . IF LPAREN exp RPAREN LCURLY block RCURLY condition1
    (57) for_loop -> . FOR ID IN RANGE LPAREN exp COMMA exp RPAREN LCURLY block RCURLY
    (58) while_loop -> . WHILE LPAREN exp RPAREN LCURLY block RCURLY
    (59) std_func -> . ID LPAREN std_func1 RPAREN
    (64) sp_func -> . generate_key_func
    (65) sp_func -> . file_func
    (66) sp_func -> . crypto_func
    (30) variable -> . ID variable1
    (75) generate_key_func -> . GENERATE_KEY LPAREN RPAREN
    (67) file_func -> . open_file
    (68) file_func -> . read_file
    (69) file_func -> . write_file
    (70) file_func -> . close_file
    (71) crypto_func -> . encrypt_func
    (72) crypto_func -> . decrypt_func
    (73) crypto_func -> . hash_sha256
    (74) crypto_func -> . hash_md5
    (76) open_file -> . OPEN LPAREN CTE_CHAR RPAREN
    (77) read_file -> . READ LPAREN ID RPAREN
    (78) write_file -> . WRITE LPAREN CTE_CHAR ID RPAREN
    (79) close_file -> . CLOSE LPAREN ID RPAREN
    (80) encrypt_func -> . ENCRYPT LPAREN encrypt_func1 COMMA ID RPAREN
    (83) decrypt_func -> . DECRYPT LPAREN decrypt_func1 COMMA ID RPAREN
    (86) hash_sha256 -> . HASH_SHA256 LPAREN hash_sha2561 RPAREN
    (89) hash_md5 -> . HASH_MD5 LPAREN hash_md51 RPAREN

    RCURLY          reduce using rule 119 (empty -> .)
    INPUT           shift and go to state 96
    PRINT           shift and go to state 97
    IF              shift and go to state 98
    FOR             shift and go to state 99
    WHILE           shift and go to state 101
    ID              shift and go to state 100
    GENERATE_KEY    shift and go to state 105
    OPEN            shift and go to state 114
    READ            shift and go to state 115
    WRITE           shift and go to state 116
    CLOSE           shift and go to state 117
    ENCRYPT         shift and go to state 118
    DECRYPT         shift and go to state 119
    HASH_SHA256     shift and go to state 120
    HASH_MD5        shift and go to state 121

    block                          shift and go to state 269
    statement                      shift and go to state 85
    empty                          shift and go to state 86
    assignment                     shift and go to state 87
    c_input                        shift and go to state 88
    c_print                        shift and go to state 89
    condition                      shift and go to state 90
    for_loop                       shift and go to state 91
    while_loop                     shift and go to state 92
    std_func                       shift and go to state 93
    sp_func                        shift and go to state 94
    variable                       shift and go to state 95
    generate_key_func              shift and go to state 102
    file_func                      shift and go to state 103
    crypto_func                    shift and go to state 104
    open_file                      shift and go to state 106
    read_file                      shift and go to state 107
    write_file                     shift and go to state 108
    close_file                     shift and go to state 109
    encrypt_func                   shift and go to state 110
    decrypt_func                   shift and go to state 111
    hash_sha256                    shift and go to state 112
    hash_md5                       shift and go to state 113

state 267

    (57) for_loop -> FOR ID IN RANGE LPAREN exp COMMA exp RPAREN . LCURLY block RCURLY

    LCURLY          shift and go to state 270


state 268

    (20) function -> FUNC ID LPAREN param RPAREN ARROW smp_type LCURLY function1 block RETURN exp SEMICOL RCURLY .

    FUNC            reduce using rule 20 (function -> FUNC ID LPAREN param RPAREN ARROW smp_type LCURLY function1 block RETURN exp SEMICOL RCURLY .)
    MAIN            reduce using rule 20 (function -> FUNC ID LPAREN param RPAREN ARROW smp_type LCURLY function1 block RETURN exp SEMICOL RCURLY .)


state 269

    (55) condition1 -> ELSE LCURLY block . RCURLY

    RCURLY          shift and go to state 271


state 270

    (57) for_loop -> FOR ID IN RANGE LPAREN exp COMMA exp RPAREN LCURLY . block RCURLY
    (28) block -> . statement block
    (29) block -> . empty
    (35) statement -> . assignment
    (36) statement -> . c_input
    (37) statement -> . c_print
    (38) statement -> . condition
    (39) statement -> . for_loop
    (40) statement -> . while_loop
    (41) statement -> . std_func
    (42) statement -> . sp_func
    (119) empty -> .
    (43) assignment -> . variable EQUAL assignment1 SEMICOL
    (46) c_input -> . INPUT variable c_input1 SEMICOL
    (49) c_print -> . PRINT LPAREN c_print1 RPAREN SEMICOL
    (54) condition -> . IF LPAREN exp RPAREN LCURLY block RCURLY condition1
    (57) for_loop -> . FOR ID IN RANGE LPAREN exp COMMA exp RPAREN LCURLY block RCURLY
    (58) while_loop -> . WHILE LPAREN exp RPAREN LCURLY block RCURLY
    (59) std_func -> . ID LPAREN std_func1 RPAREN
    (64) sp_func -> . generate_key_func
    (65) sp_func -> . file_func
    (66) sp_func -> . crypto_func
    (30) variable -> . ID variable1
    (75) generate_key_func -> . GENERATE_KEY LPAREN RPAREN
    (67) file_func -> . open_file
    (68) file_func -> . read_file
    (69) file_func -> . write_file
    (70) file_func -> . close_file
    (71) crypto_func -> . encrypt_func
    (72) crypto_func -> . decrypt_func
    (73) crypto_func -> . hash_sha256
    (74) crypto_func -> . hash_md5
    (76) open_file -> . OPEN LPAREN CTE_CHAR RPAREN
    (77) read_file -> . READ LPAREN ID RPAREN
    (78) write_file -> . WRITE LPAREN CTE_CHAR ID RPAREN
    (79) close_file -> . CLOSE LPAREN ID RPAREN
    (80) encrypt_func -> . ENCRYPT LPAREN encrypt_func1 COMMA ID RPAREN
    (83) decrypt_func -> . DECRYPT LPAREN decrypt_func1 COMMA ID RPAREN
    (86) hash_sha256 -> . HASH_SHA256 LPAREN hash_sha2561 RPAREN
    (89) hash_md5 -> . HASH_MD5 LPAREN hash_md51 RPAREN

    RCURLY          reduce using rule 119 (empty -> .)
    INPUT           shift and go to state 96
    PRINT           shift and go to state 97
    IF              shift and go to state 98
    FOR             shift and go to state 99
    WHILE           shift and go to state 101
    ID              shift and go to state 100
    GENERATE_KEY    shift and go to state 105
    OPEN            shift and go to state 114
    READ            shift and go to state 115
    WRITE           shift and go to state 116
    CLOSE           shift and go to state 117
    ENCRYPT         shift and go to state 118
    DECRYPT         shift and go to state 119
    HASH_SHA256     shift and go to state 120
    HASH_MD5        shift and go to state 121

    block                          shift and go to state 272
    statement                      shift and go to state 85
    empty                          shift and go to state 86
    assignment                     shift and go to state 87
    c_input                        shift and go to state 88
    c_print                        shift and go to state 89
    condition                      shift and go to state 90
    for_loop                       shift and go to state 91
    while_loop                     shift and go to state 92
    std_func                       shift and go to state 93
    sp_func                        shift and go to state 94
    variable                       shift and go to state 95
    generate_key_func              shift and go to state 102
    file_func                      shift and go to state 103
    crypto_func                    shift and go to state 104
    open_file                      shift and go to state 106
    read_file                      shift and go to state 107
    write_file                     shift and go to state 108
    close_file                     shift and go to state 109
    encrypt_func                   shift and go to state 110
    decrypt_func                   shift and go to state 111
    hash_sha256                    shift and go to state 112
    hash_md5                       shift and go to state 113

state 271

    (55) condition1 -> ELSE LCURLY block RCURLY .

    INPUT           reduce using rule 55 (condition1 -> ELSE LCURLY block RCURLY .)
    PRINT           reduce using rule 55 (condition1 -> ELSE LCURLY block RCURLY .)
    IF              reduce using rule 55 (condition1 -> ELSE LCURLY block RCURLY .)
    FOR             reduce using rule 55 (condition1 -> ELSE LCURLY block RCURLY .)
    WHILE           reduce using rule 55 (condition1 -> ELSE LCURLY block RCURLY .)
    ID              reduce using rule 55 (condition1 -> ELSE LCURLY block RCURLY .)
    GENERATE_KEY    reduce using rule 55 (condition1 -> ELSE LCURLY block RCURLY .)
    OPEN            reduce using rule 55 (condition1 -> ELSE LCURLY block RCURLY .)
    READ            reduce using rule 55 (condition1 -> ELSE LCURLY block RCURLY .)
    WRITE           reduce using rule 55 (condition1 -> ELSE LCURLY block RCURLY .)
    CLOSE           reduce using rule 55 (condition1 -> ELSE LCURLY block RCURLY .)
    ENCRYPT         reduce using rule 55 (condition1 -> ELSE LCURLY block RCURLY .)
    DECRYPT         reduce using rule 55 (condition1 -> ELSE LCURLY block RCURLY .)
    HASH_SHA256     reduce using rule 55 (condition1 -> ELSE LCURLY block RCURLY .)
    HASH_MD5        reduce using rule 55 (condition1 -> ELSE LCURLY block RCURLY .)
    RCURLY          reduce using rule 55 (condition1 -> ELSE LCURLY block RCURLY .)
    RETURN          reduce using rule 55 (condition1 -> ELSE LCURLY block RCURLY .)


state 272

    (57) for_loop -> FOR ID IN RANGE LPAREN exp COMMA exp RPAREN LCURLY block . RCURLY

    RCURLY          shift and go to state 273


state 273

    (57) for_loop -> FOR ID IN RANGE LPAREN exp COMMA exp RPAREN LCURLY block RCURLY .

    INPUT           reduce using rule 57 (for_loop -> FOR ID IN RANGE LPAREN exp COMMA exp RPAREN LCURLY block RCURLY .)
    PRINT           reduce using rule 57 (for_loop -> FOR ID IN RANGE LPAREN exp COMMA exp RPAREN LCURLY block RCURLY .)
    IF              reduce using rule 57 (for_loop -> FOR ID IN RANGE LPAREN exp COMMA exp RPAREN LCURLY block RCURLY .)
    FOR             reduce using rule 57 (for_loop -> FOR ID IN RANGE LPAREN exp COMMA exp RPAREN LCURLY block RCURLY .)
    WHILE           reduce using rule 57 (for_loop -> FOR ID IN RANGE LPAREN exp COMMA exp RPAREN LCURLY block RCURLY .)
    ID              reduce using rule 57 (for_loop -> FOR ID IN RANGE LPAREN exp COMMA exp RPAREN LCURLY block RCURLY .)
    GENERATE_KEY    reduce using rule 57 (for_loop -> FOR ID IN RANGE LPAREN exp COMMA exp RPAREN LCURLY block RCURLY .)
    OPEN            reduce using rule 57 (for_loop -> FOR ID IN RANGE LPAREN exp COMMA exp RPAREN LCURLY block RCURLY .)
    READ            reduce using rule 57 (for_loop -> FOR ID IN RANGE LPAREN exp COMMA exp RPAREN LCURLY block RCURLY .)
    WRITE           reduce using rule 57 (for_loop -> FOR ID IN RANGE LPAREN exp COMMA exp RPAREN LCURLY block RCURLY .)
    CLOSE           reduce using rule 57 (for_loop -> FOR ID IN RANGE LPAREN exp COMMA exp RPAREN LCURLY block RCURLY .)
    ENCRYPT         reduce using rule 57 (for_loop -> FOR ID IN RANGE LPAREN exp COMMA exp RPAREN LCURLY block RCURLY .)
    DECRYPT         reduce using rule 57 (for_loop -> FOR ID IN RANGE LPAREN exp COMMA exp RPAREN LCURLY block RCURLY .)
    HASH_SHA256     reduce using rule 57 (for_loop -> FOR ID IN RANGE LPAREN exp COMMA exp RPAREN LCURLY block RCURLY .)
    HASH_MD5        reduce using rule 57 (for_loop -> FOR ID IN RANGE LPAREN exp COMMA exp RPAREN LCURLY block RCURLY .)
    RCURLY          reduce using rule 57 (for_loop -> FOR ID IN RANGE LPAREN exp COMMA exp RPAREN LCURLY block RCURLY .)
    RETURN          reduce using rule 57 (for_loop -> FOR ID IN RANGE LPAREN exp COMMA exp RPAREN LCURLY block RCURLY .)

